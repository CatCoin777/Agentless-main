{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..b72e8bc 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1458,14 +1458,7 @@ class LineCollection(Collection):\n             List of segments in the LineCollection. Each list item contains an\n             array of vertices.\n         \"\"\"\n-        segments = []\n-\n-        for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n-            segments.append(vertices)\n-\n-        return segments\n+        return [path.vertices for path in self._paths]\n \n     def _add_offsets(self, segs):\n         offsets = self._uniform_offsets\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..cab0a52 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2021,8 +2021,11 @@ default: %(va)s\n                     j, k = key\n                     # recursively add the nested mosaic\n                     rows, cols = nested_mosaic.shape\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 49e42c8..27d6fb2 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -458,14 +458,14 @@ def make_margin_suptitles(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._suptitle.get_position()\n         if getattr(fig._suptitle, '_autopos', False):\n             fig._suptitle.set_position((p[0], 1 - h_pad_local))\n-            bbox = inv_trans_fig(fig._suptitle.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._suptitle.get_window_extent(renderer))\n             layoutgrids[fig].edit_margin_min('top', bbox.height + 2 * h_pad)\n \n     if fig._supxlabel is not None and fig._supxlabel.get_in_layout():\n         p = fig._supxlabel.get_position()\n         if getattr(fig._supxlabel, '_autopos', False):\n             fig._supxlabel.set_position((p[0], h_pad_local))\n-            bbox = inv_trans_fig(fig._supxlabel.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._supxlabel.get_window_extent(renderer))\n             layoutgrids[fig].edit_margin_min('bottom',\n                                              bbox.height + 2 * h_pad)\n \n@@ -473,7 +473,7 @@ def make_margin_suptitles(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._supylabel.get_position()\n         if getattr(fig._supylabel, '_autopos', False):\n             fig._supylabel.set_position((w_pad_local, p[1]))\n-            bbox = inv_trans_fig(fig._supylabel.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._supylabel.get_window_extent(renderer))\n             layoutgrids[fig].edit_margin_min('left', bbox.width + 2 * w_pad)\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..dc07d9d 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -297,8 +297,8 @@ class _HeatMapper:\n         despine(ax=ax, left=True, bottom=True)\n \n         # setting vmin/vmax in addition to norm is deprecated\n-        # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n+        # so avoid setting if norm is set and not None\n+        if \"norm\" not in kws or kws[\"norm\"] is None:\n             kws.setdefault(\"vmin\", self.vmin)\n             kws.setdefault(\"vmax\", self.vmax)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..4d994d5 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -184,7 +184,7 @@ def dim_section(obj):\n def array_section(obj):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n-    collapsed = \"\"\n+    collapsed = False\n     variable = getattr(obj, \"variable\", obj)\n     preview = escape(inline_variable_array_repr(variable, max_width=70))\n     data_repr = short_data_repr_html(obj)\n@@ -221,6 +221,7 @@ attr_section = partial(\n     name=\"Attributes\",\n     details_func=summarize_attrs,\n     max_items_collapse=10,\n+    collapsed=False,\n )\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py\nindex 4272598..153ddaa 100644\n--- a/xarray/core/formatting.py\n+++ b/xarray/core/formatting.py\n@@ -141,6 +141,9 @@ def format_item(x, timedelta_format=None, quote_strings=True):\n     if isinstance(x, (np.timedelta64, timedelta)):\n         return format_timedelta(x, timedelta_format=timedelta_format)\n     elif isinstance(x, (str, bytes)):\n+        # Avoid quoting strings that contain LaTeX expressions\n+        if isinstance(x, str) and x.startswith(r\"$\") and x.endswith(r\"$\"):\n+            return x\n         return repr(x) if quote_strings else x\n     elif np.issubdtype(type(x), np.floating):\n         return f\"{x:.4}\"\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..0da0836 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,10 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for external use.\n+        # matcher = NodeMatcher(translated=Any)\n+        # for translated in self.document.findall(matcher):  # type: nodes.Element\n+        #     translated.delattr('translated')\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..ac97e44 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', ok)\n         if not d['path']:\n             sys.exit(1)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d19d26f..5ecd95a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1452,7 +1452,7 @@ class LatexPrinter(Printer):\n     def _print_SingularityFunction(self, expr):\n         shift = self._print(expr.args[0] - expr.args[1])\n         power = self._print(expr.args[2])\n-        tex = r\"{\\langle %s \\rangle}^ %s\" % (shift, power)\n+        tex = r\"{\\langle %s \\rangle}^{%s}\" % (shift, power)\n         return tex\n \n     def _print_Heaviside(self, expr, exp=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..8cbaeb6 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -559,12 +559,18 @@ def draw_networkx_edges(\n     label : [None| string]\n        Label for legend\n \n+    nodelist : list, optional (default=None)\n+       Draw only edges between the specified nodes (default=G.nodes())\n+\n     min_source_margin : int, optional (default=0)\n-       The minimum margin (gap) at the begining of the edge at the source.\n+       The minimum margin (gap) at the beginning of the edge at the source.\n \n     min_target_margin : int, optional (default=0)\n        The minimum margin (gap) at the end of the edge at the target.\n \n+    nodelist : list, optional (default=None)\n+       Draw only edges between the specified nodes (default=G.nodes())\n+\n     Returns\n     -------\n     list of matplotlib.patches.FancyArrowPatch\n@@ -628,12 +634,15 @@ def draw_networkx_edges(\n     if edgelist is None:\n         edgelist = list(G.edges())\n \n-    if len(edgelist) == 0:  # no edges!\n-        return []\n-\n     if nodelist is None:\n         nodelist = list(G.nodes())\n \n+    # Filter edgelist to include only edges with both nodes in nodelist\n+    edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n+\n+    if len(edgelist) == 0:  # no edges!\n+        return []\n+\n     # FancyArrowPatch handles color=None different from LineCollection\n     if edge_color is None:\n         edge_color = \"k\"\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-1966", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 897ecfd..b873583 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1267,7 +1267,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"row\":\n                     row = m.val_map[val]\n                     if args[\"facet_row\"] and len(row_labels) < row:\n-                        row_labels.append(args[\"facet_row\"] + \"=\" + str(val))\n+                        row_labels.append(get_decorated_label(args, args[\"facet_row\"], \"facet_row\") + \"=\" + str(val))\n                 else:\n                     if (\n                         bool(args.get(\"marginal_x\", False))\n@@ -1282,7 +1282,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"col\":\n                     col = m.val_map[val]\n                     if args[\"facet_col\"] and len(col_labels) < col:\n-                        col_labels.append(args[\"facet_col\"] + \"=\" + str(val))\n+                        col_labels.append(get_decorated_label(args, args[\"facet_col\"], \"facet_col\") + \"=\" + str(val))\n                     if facet_col_wrap:  # assumes no facet_row, no marginals\n                         row = 1 + ((col - 1) // facet_col_wrap)\n                         col = 1 + ((col - 1) % facet_col_wrap)\n"}
