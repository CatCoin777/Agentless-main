{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..62ddcf4 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1461,8 +1461,7 @@ class LineCollection(Collection):\n         segments = []\n \n         for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n+            vertices = path.vertices\n             segments.append(vertices)\n \n         return segments\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..4d0dcfd 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2021,8 +2021,13 @@ default: %(va)s\n                     j, k = key\n                     # recursively add the nested mosaic\n                     rows, cols = nested_mosaic.shape\n+                    # Create a copy of gridspec_kw without width_ratios and height_ratios\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n+                    \n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 49e42c8..7bfeb6c 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -458,7 +458,7 @@ def make_margin_suptitles(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._suptitle.get_position()\n         if getattr(fig._suptitle, '_autopos', False):\n             fig._suptitle.set_position((p[0], 1 - h_pad_local))\n-            bbox = inv_trans_fig(fig._suptitle.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._suptitle.get_window_extent(renderer=renderer))\n             layoutgrids[fig].edit_margin_min('top', bbox.height + 2 * h_pad)\n \n     if fig._supxlabel is not None and fig._supxlabel.get_in_layout():\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..49aafd7 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -296,11 +296,9 @@ class _HeatMapper:\n         # Remove all the Axes spines\n         despine(ax=ax, left=True, bottom=True)\n \n-        # setting vmin/vmax in addition to norm is deprecated\n-        # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n-            kws.setdefault(\"vmin\", self.vmin)\n-            kws.setdefault(\"vmax\", self.vmax)\n+        # Ensure vmin and vmax are set regardless of whether norm is specified\n+        kws.setdefault(\"vmin\", self.vmin)\n+        kws.setdefault(\"vmax\", self.vmax)\n \n         # Draw the heatmap\n         mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..684afdf 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -184,7 +184,7 @@ def dim_section(obj):\n def array_section(obj):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n-    collapsed = \"\"\n+    collapsed = \"checked\"\n     variable = getattr(obj, \"variable\", obj)\n     preview = escape(inline_variable_array_repr(variable, max_width=70))\n     data_repr = short_data_repr_html(obj)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py\nindex 4272598..0b8bb86 100644\n--- a/xarray/core/formatting.py\n+++ b/xarray/core/formatting.py\n@@ -141,7 +141,7 @@ def format_item(x, timedelta_format=None, quote_strings=True):\n     if isinstance(x, (np.timedelta64, timedelta)):\n         return format_timedelta(x, timedelta_format=timedelta_format)\n     elif isinstance(x, (str, bytes)):\n-        return repr(x) if quote_strings else x\n+        return x if quote_strings else x\n     elif np.issubdtype(type(x), np.floating):\n         return f\"{x:.4}\"\n     else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..ce7f9b2 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,10 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for use by extensions.\n+        # matcher = NodeMatcher(translated=Any)\n+        # for translated in self.document.findall(matcher):  # type: nodes.Element\n+        #     translated.delattr('translated')\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..66266c2 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -146,6 +146,9 @@ def do_prompt(text: str, default: str = None, validator: Callable[[str], Any] =\n         else:\n             prompt = colorize(COLOR_QUESTION, prompt, input_mode=False)\n         x = term_input(prompt).strip()\n+        if not x:\n+            # Handle the empty input case explicitly\n+            return False\n         if default and not x:\n             x = default\n         try:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d19d26f..5ecd95a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1452,7 +1452,7 @@ class LatexPrinter(Printer):\n     def _print_SingularityFunction(self, expr):\n         shift = self._print(expr.args[0] - expr.args[1])\n         power = self._print(expr.args[2])\n-        tex = r\"{\\langle %s \\rangle}^ %s\" % (shift, power)\n+        tex = r\"{\\langle %s \\rangle}^{%s}\" % (shift, power)\n         return tex\n \n     def _print_Heaviside(self, expr, exp=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-1966", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 897ecfd..cacc165 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1267,7 +1267,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"row\":\n                     row = m.val_map[val]\n                     if args[\"facet_row\"] and len(row_labels) < row:\n-                        row_labels.append(args[\"facet_row\"] + \"=\" + str(val))\n+                        row_labels.append(get_decorated_label(args, args[\"facet_row\"], args[\"facet_row\"]) + \"=\" + str(val))\n                 else:\n                     if (\n                         bool(args.get(\"marginal_x\", False))\n@@ -1282,7 +1282,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"col\":\n                     col = m.val_map[val]\n                     if args[\"facet_col\"] and len(col_labels) < col:\n-                        col_labels.append(args[\"facet_col\"] + \"=\" + str(val))\n+                        col_labels.append(get_decorated_label(args, args[\"facet_col\"], args[\"facet_col\"]) + \"=\" + str(val))\n                     if facet_col_wrap:  # assumes no facet_row, no marginals\n                         row = 1 + ((col - 1) // facet_col_wrap)\n                         col = 1 + ((col - 1) % facet_col_wrap)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..4a4bf04 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -565,6 +565,9 @@ def draw_networkx_edges(\n     min_target_margin : int, optional (default=0)\n        The minimum margin (gap) at the end of the edge at the target.\n \n+    nodelist : list, optional (default=None)\n+       Draw only edges that are incident to nodes in the nodelist. If None, draw all edges.\n+\n     Returns\n     -------\n     list of matplotlib.patches.FancyArrowPatch\n@@ -627,6 +630,9 @@ def draw_networkx_edges(\n \n     if edgelist is None:\n         edgelist = list(G.edges())\n+    \n+    if nodelist is not None:\n+        edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n \n     if len(edgelist) == 0:  # no edges!\n         return []\n"}
