{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..62ddcf4 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1461,8 +1461,7 @@ class LineCollection(Collection):\n         segments = []\n \n         for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n+            vertices = path.vertices\n             segments.append(vertices)\n \n         return segments\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..e313854 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2021,8 +2021,12 @@ default: %(va)s\n                     j, k = key\n                     # recursively add the nested mosaic\n                     rows, cols = nested_mosaic.shape\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    # Remove width_ratios and height_ratios for nested levels\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 49e42c8..7bfeb6c 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -458,7 +458,7 @@ def make_margin_suptitles(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._suptitle.get_position()\n         if getattr(fig._suptitle, '_autopos', False):\n             fig._suptitle.set_position((p[0], 1 - h_pad_local))\n-            bbox = inv_trans_fig(fig._suptitle.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._suptitle.get_window_extent(renderer=renderer))\n             layoutgrids[fig].edit_margin_min('top', bbox.height + 2 * h_pad)\n \n     if fig._supxlabel is not None and fig._supxlabel.get_in_layout():\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..8c1aef2 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -298,7 +298,7 @@ class _HeatMapper:\n \n         # setting vmin/vmax in addition to norm is deprecated\n         # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n+        if \"norm\" not in kws or kws[\"norm\"] is None:\n             kws.setdefault(\"vmin\", self.vmin)\n             kws.setdefault(\"vmax\", self.vmax)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..ee324ac 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -147,7 +147,8 @@ def collapsible_section(\n     has_items = n_items is not None and n_items\n     n_items_span = \"\" if n_items is None else f\" <span>({n_items})</span>\"\n     enabled = \"\" if enabled and has_items else \"disabled\"\n-    collapsed = \"\" if collapsed or not has_items else \"checked\"\n+    # Change the default to not collapsed\n+    collapsed = \"\" if collapsed or not has_items else \"\"\n     tip = \" title='Expand/collapse section'\" if enabled else \"\"\n \n     return (\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/plot/utils.py b/xarray/plot/utils.py\nindex 4a784fa..e348b0f 100644\n--- a/xarray/plot/utils.py\n+++ b/xarray/plot/utils.py\n@@ -468,6 +468,11 @@ def label_from_attrs(da, extra=\"\"):\n \n     if da.attrs.get(\"long_name\"):\n         name = da.attrs[\"long_name\"]\n+        # Check if the long_name contains LaTeX expression and wrap it in $\n+        if name.startswith(r\"$\") and name.endswith(r\"$\"):\n+            name = name\n+        else:\n+            name = r\"${}$\".format(name)\n     elif da.attrs.get(\"standard_name\"):\n         name = da.attrs[\"standard_name\"]\n     elif da.name is not None:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..82f18a6 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,7 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for use by extensions.\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..3fa0c73 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -146,6 +146,9 @@ def do_prompt(text: str, default: str = None, validator: Callable[[str], Any] =\n         else:\n             prompt = colorize(COLOR_QUESTION, prompt, input_mode=False)\n         x = term_input(prompt).strip()\n+        if not x:\n+            # User pressed Enter to exit\n+            return False\n         if default and not x:\n             x = default\n         try:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 9713f56..72a9492 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1148,7 +1148,7 @@ class PrettyPrinter(Printer):\n             base = prettyForm(\"<\")\n             base = prettyForm(*base.right(shift))\n             base = prettyForm(*base.right(\">\"))\n-            pform = base**n\n+            pform = prettyForm(*base.right(f\"^{n}\"))\n             return pform\n         else:\n             return self._print_Function(e)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..d5be20e 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -565,6 +565,9 @@ def draw_networkx_edges(\n     min_target_margin : int, optional (default=0)\n        The minimum margin (gap) at the end of the edge at the target.\n \n+    nodelist : list, optional (default=G.nodes())\n+        Draw only edges between the specified nodes.\n+\n     Returns\n     -------\n     list of matplotlib.patches.FancyArrowPatch\n@@ -584,6 +587,12 @@ def draw_networkx_edges(\n     >>> G = nx.dodecahedral_graph()\n     >>> edges = nx.draw_networkx_edges(G, pos=nx.spring_layout(G))\n \n+    >>> G = nx.path_graph(3)\n+    >>> pos = {n: (n, n) for n in range(len(G))}\n+    >>> nx.draw_networkx_nodes(G, pos, nodelist=[0, 1])\n+    >>> nx.draw_networkx_edges(G, pos, nodelist=[0, 1])\n+    # This will draw only the edge between nodes 0 and 1, excluding edge (1, 2).\n+\n     >>> G = nx.DiGraph()\n     >>> G.add_edges_from([(1, 2), (1, 3), (2, 3)])\n     >>> arcs = nx.draw_networkx_edges(G, pos=nx.spring_layout(G))\n@@ -634,6 +643,9 @@ def draw_networkx_edges(\n     if nodelist is None:\n         nodelist = list(G.nodes())\n \n+    # Filter edgelist to include only edges between nodes in nodelist\n+    edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n+\n     # FancyArrowPatch handles color=None different from LineCollection\n     if edge_color is None:\n         edge_color = \"k\"\n"}
