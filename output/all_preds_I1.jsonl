{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..62ddcf4 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1461,8 +1461,7 @@ class LineCollection(Collection):\n         segments = []\n \n         for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n+            vertices = path.vertices\n             segments.append(vertices)\n \n         return segments\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..cab0a52 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2021,8 +2021,11 @@ default: %(va)s\n                     j, k = key\n                     # recursively add the nested mosaic\n                     rows, cols = nested_mosaic.shape\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 49e42c8..1ae9cab 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -458,7 +458,7 @@ def make_margin_suptitles(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._suptitle.get_position()\n         if getattr(fig._suptitle, '_autopos', False):\n             fig._suptitle.set_position((p[0], 1 - h_pad_local))\n-            bbox = inv_trans_fig(fig._suptitle.get_tightbbox(renderer))\n+            bbox = inv_trans_fig(fig._suptitle.get_window_extent(renderer))\n             layoutgrids[fig].edit_margin_min('top', bbox.height + 2 * h_pad)\n \n     if fig._supxlabel is not None and fig._supxlabel.get_in_layout():\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..e36fa06 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -298,9 +298,8 @@ class _HeatMapper:\n \n         # setting vmin/vmax in addition to norm is deprecated\n         # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n-            kws.setdefault(\"vmin\", self.vmin)\n-            kws.setdefault(\"vmax\", self.vmax)\n+        kws.setdefault(\"vmin\", self.vmin)\n+        kws.setdefault(\"vmax\", self.vmax)\n \n         # Draw the heatmap\n         mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..413a4d4 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -139,7 +139,7 @@ def summarize_vars(variables):\n \n \n def collapsible_section(\n-    name, inline_details=\"\", details=\"\", n_items=None, enabled=True, collapsed=False\n+    name, inline_details=\"\", details=\"\", n_items=None, enabled=True, collapsed=True\n ):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/plot/utils.py b/xarray/plot/utils.py\nindex 4a784fa..b51005e 100644\n--- a/xarray/plot/utils.py\n+++ b/xarray/plot/utils.py\n@@ -490,7 +490,10 @@ def label_from_attrs(da, extra=\"\"):\n     else:\n         units = _get_units_from_attrs(da)\n \n-    return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n+    if name.startswith(\"$\") and name.endswith(\"$\"):\n+        return name + extra + units\n+    else:\n+        return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n \n \n def _interval_to_mid_points(array):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..82f18a6 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,7 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for use by extensions.\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..f67b2e8 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -148,6 +148,8 @@ def do_prompt(text: str, default: str = None, validator: Callable[[str], Any] =\n         x = term_input(prompt).strip()\n         if default and not x:\n             x = default\n+        if text == \"Please enter a new root path name (or just Enter to exit)\" and not x:\n+            return False\n         try:\n             x = validator(x)\n         except ValidationError as err:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 9713f56..1c905eb 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1143,12 +1143,12 @@ class PrettyPrinter(Printer):\n \n     def _print_SingularityFunction(self, e):\n         if self._use_unicode:\n-            shift = self._print(e.args[0]-e.args[1])\n+            shift = self._print(e.args[0] - e.args[1])\n             n = self._print(e.args[2])\n             base = prettyForm(\"<\")\n             base = prettyForm(*base.right(shift))\n             base = prettyForm(*base.right(\">\"))\n-            pform = base**n\n+            pform = prettyForm(*base.right(f\"^{n}\"))\n             return pform\n         else:\n             return self._print_Function(e)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..5aa1a93 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -495,6 +495,11 @@ def draw_networkx_edges(\n ):\n     \"\"\"Draw the edges of the graph G.\n \n+    Parameters\n+    ----------\n+    nodelist : list, optional (default=list(G.nodes()))\n+       Draw only edges that are incident on nodes in the nodelist.\n+\n     This draws only the edges of the graph G.\n \n     Parameters\n@@ -628,12 +633,15 @@ def draw_networkx_edges(\n     if edgelist is None:\n         edgelist = list(G.edges())\n \n-    if len(edgelist) == 0:  # no edges!\n-        return []\n-\n     if nodelist is None:\n         nodelist = list(G.nodes())\n \n+    # Filter edgelist to include only edges incident on nodes in nodelist\n+    edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n+\n+    if len(edgelist) == 0:  # no edges!\n+        return []\n+\n     # FancyArrowPatch handles color=None different from LineCollection\n     if edge_color is None:\n         edge_color = \"k\"\n"}
