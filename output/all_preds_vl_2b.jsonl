{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-11693", "model_patch": "diff --git a/astropy/wcs/wcsapi/fitswcs.py b/astropy/wcs/wcsapi/fitswcs.py\nindex ce29e86..e2df1a5 100644\n--- a/astropy/wcs/wcsapi/fitswcs.py\n+++ b/astropy/wcs/wcsapi/fitswcs.py\n@@ -323,7 +323,7 @@ class FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        pixel = self.all_world2pix(*world_arrays, 0, quiet=True)\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13838", "model_patch": "diff --git a/astropy/table/pprint.py b/astropy/table/pprint.py\nindex 2d557c7..589a042 100644\n--- a/astropy/table/pprint.py\n+++ b/astropy/table/pprint.py\n@@ -476,10 +476,18 @@ class TableFormatter:\n                 # with shape (n,1,...,1) from being printed as if there was\n                 # more than one element in a row\n                 if trivial_multidims:\n+                    if col[(idx,) + multidim0].size == 0:\n+                        return '[]'\n                     return format_func(col_format, col[(idx,) + multidim0])\n                 else:\n-                    left = format_func(col_format, col[(idx,) + multidim0])\n-                    right = format_func(col_format, col[(idx,) + multidim1])\n+                    if col[(idx,) + multidim0].size == 0:\n+                        left = '[]'\n+                    else:\n+                        left = format_func(col_format, col[(idx,) + multidim0])\n+                    if col[(idx,) + multidim1].size == 0:\n+                        right = '[]'\n+                    else:\n+                        right = format_func(col_format, col[(idx,) + multidim1])\n                     return f'{left} .. {right}'\n             else:\n                 return format_func(col_format, col[idx])\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14295", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex cf86591..f39bd22 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -705,51 +705,8 @@ reduce these to 2 dimensions using the naxis kwarg.\n     if _wcs is not None:\n         sub.__doc__ = _wcs.Wcsprm.sub.__doc__\n \n-    def _fix_scamp(self):\n-        \"\"\"\n-        Remove SCAMP's PVi_m distortion parameters if SIP distortion parameters\n-        are also present. Some projects (e.g., Palomar Transient Factory)\n-        convert SCAMP's distortion parameters (which abuse the PVi_m cards) to\n-        SIP. However, wcslib gets confused by the presence of both SCAMP and\n-        SIP distortion parameters.\n-\n-        See https://github.com/astropy/astropy/issues/299.\n-        \"\"\"\n-        # Nothing to be done if no WCS attached\n-        if self.wcs is None:\n-            return\n-\n-        # Nothing to be done if no PV parameters attached\n-        pv = self.wcs.get_pv()\n-        if not pv:\n-            return\n-\n-        # Nothing to be done if axes don't use SIP distortion parameters\n-        if self.sip is None:\n-            return\n-\n-        # Nothing to be done if any radial terms are present...\n-        # Loop over list to find any radial terms.\n-        # Certain values of the `j' index are used for storing\n-        # radial terms; refer to Equation (1) in\n-        # <http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf>.\n-        pv = np.asarray(pv)\n-        # Loop over distinct values of `i' index\n-        for i in set(pv[:, 0]):\n-            # Get all values of `j' index for this value of `i' index\n-            js = set(pv[:, 1][pv[:, 0] == i])\n-            # Find max value of `j' index\n-            max_j = max(js)\n-            for j in (3, 11, 23, 39):\n-                if j < max_j and j in js:\n-                    return\n-\n-        self.wcs.set_pv([])\n-        warnings.warn(\n-            \"Removed redundant SCAMP distortion parameters \"\n-            + \"because SIP parameters are also present\",\n-            FITSFixedWarning,\n-        )\n+        # Removed _fix_scamp method to avoid heuristic code handling PTF files\n+        pass\n \n     def fix(self, translate_units=\"\", naxis=None):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-8292", "model_patch": "diff --git a/astropy/units/equivalencies.py b/astropy/units/equivalencies.py\nindex ac09b48..e6dbb91 100644\n--- a/astropy/units/equivalencies.py\n+++ b/astropy/units/equivalencies.py\n@@ -728,6 +728,9 @@ def with_H0(H0=None):\n         from astropy import cosmology\n         H0 = cosmology.default_cosmology.get().H0\n \n-    h100_val_unit = Unit(H0.to((si.km/si.s)/astrophys.Mpc).value/100 * astrophys.littleh)\n+    h_val = H0.to((si.km/si.s)/astrophys.Mpc).value / 100\n \n-    return [(h100_val_unit, None)]\n+    return [\n+        (astrophys.Mpc, astrophys.Mpc / astrophys.littleh, lambda x: x * h_val, lambda x: x / h_val),\n+        (astrophys.Mpc / astrophys.littleh, astrophys.Mpc, lambda x: x / h_val, lambda x: x * h_val)\n+    ]\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13908", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 9ab7174..e3fb6d1 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1324,7 +1324,7 @@ class Axis(martist.Artist):\n         tol = (hi - lo) * 1e-5\n         minor_locs = [\n             loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n-            if not np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n+            if not np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).all()]\n         return minor_locs\n \n     def get_ticklocs(self, minor=False):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13980", "model_patch": "diff --git a/lib/matplotlib/projections/polar.py b/lib/matplotlib/projections/polar.py\nindex ffdbea1..9d02e70 100644\n--- a/lib/matplotlib/projections/polar.py\n+++ b/lib/matplotlib/projections/polar.py\n@@ -951,7 +951,9 @@ class PolarAxes(Axes):\n         if thetamin > thetamax:\n             thetamin, thetamax = thetamax, thetamin\n         rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n-                        self.get_rsign())\n+                       self.get_rsign())\n+        if rmin < 0:\n+            rmin = 0\n         if isinstance(self.patch, mpatches.Wedge):\n             # Backwards-compatibility: Any subclassed Axes might override the\n             # patch to not be the Wedge that PolarAxes uses.\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13983", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 1ebbf68..270c042 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1596,6 +1596,10 @@ default: 'top'\n             axis.set_major_locator(axis.get_major_locator())\n             axis.set_minor_formatter(axis.get_minor_formatter())\n             axis.set_minor_locator(axis.get_minor_locator())\n+            axis.isDefault_majloc = True\n+            axis.isDefault_minloc = True\n+            axis.isDefault_majfmt = True\n+            axis.isDefault_minfmt = True\n \n         def _break_share_link(ax, grouper):\n             siblings = grouper.get_siblings(ax)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-14043", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 0a22b41..858226a 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2598,6 +2598,11 @@ class _AxesBase(martist.Artist):\n             artists.remove(self._left_title)\n             artists.remove(self._right_title)\n \n+        # Ensure error bars are added to the list of artists\n+        for container in self.containers:\n+            if hasattr(container, 'errorbar'):\n+                artists.extend(container.errorbar)\n+\n         if not self.figure.canvas.is_saving():\n             artists = [a for a in artists\n                        if not a.get_animated() or a in self.images]\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-14623", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex a94783e..98c4009 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1006,9 +1006,9 @@ class Axis(martist.Artist):\n         \"\"\"\n         a, b = self.get_view_interval()\n         if inverted:\n-            self.set_view_interval(max(a, b), min(a, b), ignore=True)\n+            self.set_view_interval(vmax, vmin, ignore=True)\n         else:\n-            self.set_view_interval(min(a, b), max(a, b), ignore=True)\n+            self.set_view_interval(vmin, vmax, ignore=True)\n \n     def set_default_intervals(self):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-19763", "model_patch": "diff --git a/lib/matplotlib/backends/backend_nbagg.py b/lib/matplotlib/backends/backend_nbagg.py\nindex 0b924f9..57e0de9 100644\n--- a/lib/matplotlib/backends/backend_nbagg.py\n+++ b/lib/matplotlib/backends/backend_nbagg.py\n@@ -159,6 +159,39 @@ class FigureManagerNbAgg(FigureManagerWebAgg):\n class FigureCanvasNbAgg(FigureCanvasWebAggCore):\n     manager_class = FigureManagerNbAgg\n \n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self._cursor_timer = None\n+\n+    def start_cursor_timer(self):\n+        if self._cursor_timer is None:\n+            self._cursor_timer = self.new_timer(interval=100)  # 100 ms interval\n+            self._cursor_timer.add_callback(self.refresh_canvas)\n+            self._cursor_timer.start()\n+\n+    def stop_cursor_timer(self):\n+        if self._cursor_timer is not None:\n+            self._cursor_timer.stop()\n+            self._cursor_timer = None\n+\n+    def refresh_canvas(self):\n+        self.draw_idle()\n+        return True  # Keep the timer running\n+\n+    def mpl_connect(self, s, func):\n+        cid = super().mpl_connect(s, func)\n+        if s == 'motion_notify_event':\n+            self.start_cursor_timer()\n+        return cid\n+\n+    def mpl_disconnect(self, cid):\n+        super().mpl_disconnect(cid)\n+        # Assuming there is a way to check if this was a motion_notify_event\n+        # If not, we might need to track all connected events and their types\n+        # For simplicity, we stop the timer here; this might need more sophisticated handling\n+        self.stop_cursor_timer()\n+        return cid\n+\n \n class CommSocket:\n     \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20470", "model_patch": "diff --git a/lib/matplotlib/legend_handler.py b/lib/matplotlib/legend_handler.py\nindex 5b5e7eb..32e2440 100644\n--- a/lib/matplotlib/legend_handler.py\n+++ b/lib/matplotlib/legend_handler.py\n@@ -36,6 +36,7 @@ from matplotlib import _api, cbook\n from matplotlib.lines import Line2D\n from matplotlib.patches import Rectangle\n import matplotlib.collections as mcoll\n+from matplotlib.text import Text\n \n \n def update_from_first_child(tgt, src):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20518", "model_patch": "diff --git a/lib/matplotlib/backends/backend_pgf.py b/lib/matplotlib/backends/backend_pgf.py\nindex 4adb106..b52e70f 100644\n--- a/lib/matplotlib/backends/backend_pgf.py\n+++ b/lib/matplotlib/backends/backend_pgf.py\n@@ -436,14 +436,13 @@ class RendererPgf(RendererBase):\n \n     def draw_path(self, gc, path, transform, rgbFace=None):\n         # docstring inherited\n-        writeln(self.fh, r\"\\begin{pgfscope}\")\n-        # draw the path\n-        self._print_pgf_clip(gc)\n-        self._print_pgf_path_styles(gc, rgbFace)\n-        self._print_pgf_path(gc, path, transform, rgbFace)\n-        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n-                            fill=rgbFace is not None)\n-        writeln(self.fh, r\"\\end{pgfscope}\")\n+        path_effects = gc.get_path_effects()\n+        if path_effects:\n+            renderer = PathEffectRenderer(path_effects, self)\n+        else:\n+            renderer = self\n+\n+        renderer.draw_path(gc, path, transform, rgbFace)\n \n         # if present, draw pattern on top\n         if gc.get_hatch():\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..12a4f0b 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1456,13 +1456,12 @@ class LineCollection(Collection):\n         -------\n         list\n             List of segments in the LineCollection. Each list item contains an\n-            array of vertices.\n+            array of vertices and codes.\n         \"\"\"\n         segments = []\n \n         for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n+            vertices = path.vertices\n             segments.append(vertices)\n \n         return segments\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20761", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 7d40e57..8a95dae 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -298,8 +298,9 @@ def _make_margin_suptitles(fig, renderer, *, w_pad=0, h_pad=0):\n         p = fig._supxlabel.get_position()\n         if getattr(fig._supxlabel, '_autopos', False):\n             fig._supxlabel.set_position((p[0], h_pad_local))\n-            bbox = inv_trans_fig(fig._supxlabel.get_tightbbox(renderer))\n-            fig._layoutgrid.edit_margin_min('bottom', bbox.height + 2 * h_pad)\n+        # Always get the tightbbox after setting the position, even if _autopos is False\n+        bbox = inv_trans_fig(fig._supxlabel.get_tightbbox(renderer))\n+        fig._layoutgrid.edit_margin_min('bottom', bbox.height + 2 * h_pad)\n \n     if fig._supylabel is not None and fig._supxlabel.get_in_layout():\n         p = fig._supylabel.get_position()\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20826", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 07605b5..3bdcd94 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1203,6 +1203,10 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore visibility state\n+            self.xaxis.set_visible(xaxis_visible)\n+            self.xaxis.set_ticks_position('bottom')  # Ensure ticks are only on bottom for shared x-axis\n+            self.xaxis.set_label_position('bottom')  # Ensure label is only on bottom for shared x-axis\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1215,10 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Restore visibility state\n+            self.yaxis.set_visible(yaxis_visible)\n+            self.yaxis.set_ticks_position('left')  # Ensure ticks are only on left for shared y-axis\n+            self.yaxis.set_label_position('left')  # Ensure label is only on left for shared y-axis\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21443", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 94094ef..a5d393f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -1060,6 +1060,9 @@ def axes(arg=None, **kwargs):\n     \"\"\"\n     fig = gcf()\n     if arg is None:\n+        if 'position' in kwargs:\n+            pos = kwargs.pop('position')\n+            return fig.add_axes(pos, **kwargs)\n         return fig.add_subplot(**kwargs)\n     else:\n         return fig.add_axes(arg, **kwargs)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21490", "model_patch": "diff --git a/lib/matplotlib/lines.py b/lib/matplotlib/lines.py\nindex 06a24c6..5a548f2 100644\n--- a/lib/matplotlib/lines.py\n+++ b/lib/matplotlib/lines.py\n@@ -1230,7 +1230,7 @@ class Line2D(Artist):\n         ----------\n         x : 1D array\n         \"\"\"\n-        self._xorig = x\n+        self._xorig = np.array(x, copy=True)\n         self._invalidx = True\n         self.stale = True\n \n@@ -1242,7 +1242,7 @@ class Line2D(Artist):\n         ----------\n         y : 1D array\n         \"\"\"\n-        self._yorig = y\n+        self._yorig = np.array(y, copy=True)\n         self._invalidy = True\n         self.stale = True\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21550", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 40ed06b..8929b1d 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -316,6 +316,9 @@ def draw_if_interactive(*args, **kwargs):\n         End users will typically not have to call this function because the\n         the interactive mode takes care of this.\n     \"\"\"\n+    # Speculative edit to ensure interactive drawing\n+    if plt.isinteractive():\n+        plt.pause(0.001)\n     return _backend_mod.draw_if_interactive(*args, **kwargs)\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21568", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex f565bc8..d42accc 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -596,8 +596,7 @@ def _wrap_in_tex(text):\n     ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n \n     # Braces ensure dashes are not spaced like binary operators.\n-    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n-    ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    ret_text = '$'+ret_text.replace('-', '{-}')+'$'\n     return ret_text\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21617", "model_patch": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex fb47884..aa455c4 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -678,9 +678,9 @@ grestore\n                             for x, name in xs_names)\n         self._pswriter.write(f\"\"\"\\\n gsave\n-{self._get_clip_cmd(gc)}\n {x:f} {y:f} translate\n {angle:f} rotate\n+{self._get_clip_cmd(gc)}\n {thetext}\n grestore\n \"\"\")\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22865", "model_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex 5ebeaf9..42fa49e 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -651,8 +651,13 @@ class Colorbar:\n             if not self.drawedges:\n                 if len(self._y) >= self.n_rasterize:\n                     self.solids.set_rasterized(True)\n-        self.dividers.set_segments(\n-            np.dstack([X, Y])[1:-1] if self.drawedges else [])\n+        if self.drawedges:\n+            if self.extend == 'both':\n+                self.dividers.set_segments(np.dstack([X, Y]))\n+            else:\n+                self.dividers.set_segments(np.dstack([X, Y])[1:-1])\n+        else:\n+            self.dividers.set_segments([])\n \n     def _add_solids_patches(self, X, Y, C, mappable):\n         hatches = mappable.hatches * len(C)  # Have enough hatches.\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22871", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex cc65fc1..5d2f985 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -840,7 +840,10 @@ class ConciseDateFormatter(ticker.Formatter):\n \n         if show_offset:\n             # set the offset string:\n-            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n+            if level < 2:  # This means we are dealing with days or finer granularity\n+                self.offset_string = tickdatetime[-1].strftime('%Y ' + offsetfmts[level])\n+            else:\n+                self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n             if self._usetex:\n                 self.offset_string = _wrap_in_tex(self.offset_string)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22931", "model_patch": "diff --git a/lib/matplotlib/lines.py b/lib/matplotlib/lines.py\nindex aeed546..298741a 100644\n--- a/lib/matplotlib/lines.py\n+++ b/lib/matplotlib/lines.py\n@@ -1116,11 +1116,15 @@ class Line2D(Artist):\n                 ls = ls_mapper_r[ls]\n             self._linestyle = ls\n         else:\n-            self._linestyle = '--'\n-        self._unscaled_dash_pattern = _get_dash_pattern(ls)\n-        self._dash_pattern = _scale_dashes(\n-            *self._unscaled_dash_pattern, self._linewidth)\n-        self.stale = True\n+            if isinstance(ls, tuple) and ls == (0, ()):\n+                # Special case to treat (0, ()) as a solid line\n+                self._linestyle = '-'\n+            else:\n+                self._linestyle = '--'\n+            self._unscaled_dash_pattern = _get_dash_pattern(ls)\n+            self._dash_pattern = _scale_dashes(\n+                *self._unscaled_dash_pattern, self._linewidth)\n+            self.stale = True\n \n     @_docstring.interpd\n     def set_marker(self, marker):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23047", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex b6e8396..4b9d756 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6620,8 +6620,9 @@ such objects\n                 if len(xi):\n                     # python's min/max ignore nan,\n                     # np.minnan returns nan for all nan input\n-                    xmin = min(xmin, np.nanmin(xi))\n-                    xmax = max(xmax, np.nanmax(xi))\n+                    xi_float32 = xi.astype(np.float32)\n+                    xmin = min(xmin, np.nanmin(xi_float32))\n+                    xmax = max(xmax, np.nanmax(xi_float32))\n             if xmin <= xmax:  # Only happens if we have seen a finite value.\n                 bin_range = (xmin, xmax)\n \n@@ -6634,7 +6635,7 @@ such objects\n             else:\n                 _w = None\n             bins = np.histogram_bin_edges(\n-                np.concatenate(x), bins, bin_range, _w)\n+                np.concatenate(x).astype(np.float32), bins, bin_range, _w)\n         else:\n             hist_kwargs['range'] = bin_range\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23111", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 80b1e1a..e6a3649 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -2155,10 +2155,9 @@ def _g_sig_digits(value, delta):\n     Return the number of significant digits to %g-format *value*, assuming that\n     it is known with an error of *delta*.\n     \"\"\"\n+    # Set a minimum non-zero value for delta to avoid math domain errors.\n     if delta == 0:\n-        # delta = 0 may occur when trying to format values over a tiny range;\n-        # in that case, replace it by the distance to the closest float.\n-        delta = np.spacing(value)\n+        delta = 1e-10  # or some other small non-zero value\n     # If e.g. value = 45.67 and delta = 0.02, then we want to round to 2 digits\n     # after the decimal point (floor(log10(0.02)) = -2); 45.67 contributes 2\n     # digits before the decimal point (floor(log10(45.67)) + 1 = 2): the total\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..0fa80ea 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -586,10 +586,8 @@ class Patch(artist.Artist):\n         # docstring inherited\n         if not self.get_visible():\n             return\n-        # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        # Patch now respects the dashoffset.\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24088", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 640c5be..79705eb 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2051,7 +2051,15 @@ def colorbar(mappable=None, cax=None, ax=None, **kwargs):\n             raise RuntimeError('No mappable was found to use for colorbar '\n                                'creation. First define a mappable such as '\n                                'an image (with imshow) or a contour set ('\n-                               'with contourf).')\n+                               'with contourf). If you are adding a colorbar '\n+                               'to a histogram, you need to explicitly provide '\n+                               'the `ax` argument to `plt.colorbar()`, like so:\\n'\n+                               'fig, ax = plt.subplots()\\n'\n+                               '_, bin_edges, bars = ax.hist(xs)\\n'\n+                               'color_map = getattr(plt.cm, \"hot\")\\n'\n+                               'for x_val, rect in zip(bin_edges, bars.patches):\\n'\n+                               '    rect.set_color(color_map(x_val))\\n'\n+                               'cbar = fig.colorbar(plt.cm.ScalarMappable(cmap=color_map), ax=ax)')\n     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n     return ret\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24177", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 36d6e8e..d04f3bd 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6855,6 +6855,9 @@ such objects\n                     # top of the previous polygon becomes the bottom\n                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n                 # set the top of this polygon\n+                if density:\n+                    m = m / (np.sum(m) * np.diff(bins))\n+\n                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = m + bottom\n \n                 # The starting point of the polygon has not yet been\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..1e3a078 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2019,10 +2019,10 @@ default: %(va)s\n                 elif method == 'nested':\n                     nested_mosaic = arg\n                     j, k = key\n-                    # recursively add the nested mosaic\n+                    # recursively add the nested mosaic without passing gridspec_kw\n                     rows, cols = nested_mosaic.shape\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24691", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 3884459..da672bd 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -376,8 +376,13 @@ class Patch(artist.Artist):\n     def set_alpha(self, alpha):\n         # docstring inherited\n         super().set_alpha(alpha)\n-        self._set_facecolor(self._original_facecolor)\n-        self._set_edgecolor(self._original_edgecolor)\n+        if isinstance(alpha, tuple) and len(alpha) == 2:\n+            face_alpha, edge_alpha = alpha\n+            self._set_facecolor((*mcolors.to_rgb(self._original_facecolor), face_alpha))\n+            self._set_edgecolor((*mcolors.to_rgb(self._original_edgecolor), edge_alpha))\n+        else:\n+            self._set_facecolor(self._original_facecolor)\n+            self._set_edgecolor(self._original_edgecolor)\n         # stale is already True\n \n     def set_linewidth(self, w):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24749", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex ff145f1..79a380b 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2497,6 +2497,9 @@ def cohere(\n # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n @_copy_docstring_and_deprecators(Axes.contour)\n def contour(*args, data=None, **kwargs):\n+    if 'Z' in kwargs:\n+        Z = kwargs.pop('Z')\n+        args = (Z,) + args\n     __ret = gca().contour(\n         *args, **({\"data\": data} if data is not None else {}),\n         **kwargs)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24768", "model_patch": "diff --git a/lib/matplotlib/backends/backend_mixed.py b/lib/matplotlib/backends/backend_mixed.py\nindex d4ce0aa..4b6caf0 100644\n--- a/lib/matplotlib/backends/backend_mixed.py\n+++ b/lib/matplotlib/backends/backend_mixed.py\n@@ -80,8 +80,9 @@ class MixedModeRenderer:\n                                                self._bbox_inches_restore)\n             self._bbox_inches_restore = r\n \n-        self._raster_renderer = self._raster_renderer_class(\n-            self._width*self.dpi, self._height*self.dpi, self.dpi)\n+        if self._raster_renderer is None:\n+            self._raster_renderer = self._raster_renderer_class(\n+                self._width*self.dpi, self._height*self.dpi, self.dpi)\n         self._renderer = self._raster_renderer\n \n     def stop_rasterizing(self):\n@@ -116,4 +117,4 @@ class MixedModeRenderer:\n             r = process_figure_for_rasterizing(self.figure,\n                                                self._bbox_inches_restore,\n                                                self._figdpi)\n-            self._bbox_inches_restore = r\n+            self._bbox_inches_restore = r\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24849", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex dfe01a6..05d4d08 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1474,11 +1474,42 @@ class LineCollection(Collection):\n \n     set_colors = set_color\n \n+    def set_gapcolor(self, gapcolor):\n+        \"\"\"\n+        Set a color to fill the gaps in the dashed line style.\n+\n+        .. note::\n+\n+            Striped lines are created by drawing two interleaved dashed lines.\n+            There can be overlaps between those two, which may result in\n+            artifacts when using transparency.\n+\n+            This functionality is experimental and may change.\n+\n+        Parameters\n+        ----------\n+        gapcolor : color or None\n+            The color with which to fill the gaps. If None, the gaps are\n+            unfilled.\n+        \"\"\"\n+        if gapcolor is not None:\n+            mcolors._check_color_like(color=gapcolor)\n+        self._gapcolor = gapcolor\n+        self.stale = True\n+\n     def get_color(self):\n         return self._edgecolors\n \n     get_colors = get_color  # for compatibility with old versions\n \n+    def get_gapcolor(self):\n+        \"\"\"\n+        Return the line gapcolor.\n+\n+        See also `~.Line2D.set_gapcolor`.\n+        \"\"\"\n+        return self._gapcolor\n+\n \n class EventCollection(LineCollection):\n     \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24870", "model_patch": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 908a24f..f157d8f 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1123,7 +1123,10 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n         \"\"\"\n         if self.levels is None:\n             if len(args) == 0:\n-                levels_arg = 7  # Default, hard-wired.\n+                if self.Z.dtype == bool:  # Autodetect boolean array\n+                    levels_arg = [0.5]  # Default level for boolean arrays\n+                else:\n+                    levels_arg = 7  # Default, hard-wired.\n             else:\n                 levels_arg = args[0]\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24971", "model_patch": "diff --git a/lib/matplotlib/_tight_bbox.py b/lib/matplotlib/_tight_bbox.py\nindex b0a0529..64d865b 100644\n--- a/lib/matplotlib/_tight_bbox.py\n+++ b/lib/matplotlib/_tight_bbox.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Helper module for the *bbox_inches* parameter in `.Figure.savefig`.\n \"\"\"\n@@ -21,6 +22,40 @@ def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n     fig.set_layout_engine(None)\n     _boxout = fig.transFigure._boxout\n \n+    def restore_bbox():\n+        for ax, loc, aspect in zip(fig.axes, locator_list, old_aspect):\n+            ax.set_axes_locator(loc)\n+            if aspect is sentinel:\n+                # delete our no-op function which un-hides the original method\n+                del ax.apply_aspect\n+            else:\n+                ax.apply_aspect = aspect\n+\n+        fig.bbox = origBbox\n+        fig.bbox_inches = origBboxInches\n+        fig.set_layout_engine(orig_layout)  # Restore the original layout engine\n+        fig.transFigure._boxout = _boxout\n+        fig.transFigure.invalidate()\n+        fig.patch.set_bounds(0, 0, 1, 1)\n+\n+    if fixed_dpi is None:\n+        fixed_dpi = fig.dpi\n+    tr = Affine2D().scale(fixed_dpi)\n+    dpi_scale = fixed_dpi / fig.dpi\n+\n+    fig.bbox_inches = Bbox.from_bounds(0, 0, *bbox_inches.size)\n+    x0, y0 = tr.transform(bbox_inches.p0)\n+    w1, h1 = fig.bbox.size * dpi_scale\n+    fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n+    fig.transFigure.invalidate()\n+\n+    fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n+\n+    fig.patch.set_bounds(x0 / w1, y0 / h1,\n+                         fig.bbox.width / w1, fig.bbox.height / h1)\n+\n+    return restore_bbox\n+\n     old_aspect = []\n     locator_list = []\n     sentinel = object()\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25287", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex 92db988..69e43b5 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -631,16 +631,22 @@ class Text(Artist):\n         orientation.\n         \"\"\"\n         x0, y0 = self.get_transform().transform(self.get_position())\n-        figure_box = self.get_figure().get_window_extent()\n+        # Get the renderer\n+        renderer = self.get_figure()._cachedRenderer\n+        if renderer is None:\n+            renderer = self.get_figure().canvas.get_renderer()\n+\n+        # Get the bounding box of the axes\n+        axes_box = self.get_axes().get_window_extent(renderer)\n \n         # Calculate available width based on text alignment\n         alignment = self.get_horizontalalignment()\n         self.set_rotation_mode('anchor')\n         rotation = self.get_rotation()\n \n-        left = self._get_dist_to_box(rotation, x0, y0, figure_box)\n+        left = self._get_dist_to_box(rotation, x0, y0, axes_box)\n         right = self._get_dist_to_box(\n-            (180 + rotation) % 360, x0, y0, figure_box)\n+            (180 + rotation) % 360, x0, y0, axes_box)\n \n         if alignment == 'left':\n             line_width = left\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25405", "model_patch": "diff --git a/lib/matplotlib/ticker.py b/lib/matplotlib/ticker.py\nindex 3efaa84..de86a1b 100644\n--- a/lib/matplotlib/ticker.py\n+++ b/lib/matplotlib/ticker.py\n@@ -2408,15 +2408,18 @@ class LogLocator(Locator):\n                 if stride == 1:\n                     ticklocs = np.ravel(np.outer(subs, ticklocs))\n                 else:\n-                    # No ticklocs if we have >1 decade between major ticks.\n-                    ticklocs = np.array([])\n+                    # Include minor ticks between major ticks even if stride > 1.\n+                    ticklocs = np.concatenate(\n+                        [subs * decade_start for decade_start in b ** decades])\n         else:\n             if have_subs:\n                 if stride == 1:\n                     ticklocs = np.concatenate(\n                         [subs * decade_start for decade_start in b ** decades])\n                 else:\n-                    ticklocs = np.array([])\n+                    # Include minor ticks between major ticks even if stride > 1.\n+                    ticklocs = np.concatenate(\n+                        [subs * decade_start for decade_start in b ** decades])\n             else:\n                 ticklocs = b ** decades\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25499", "model_patch": "diff --git a/lib/matplotlib/_tight_bbox.py b/lib/matplotlib/_tight_bbox.py\nindex 1836fbe..24bcc13 100644\n--- a/lib/matplotlib/_tight_bbox.py\n+++ b/lib/matplotlib/_tight_bbox.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Helper module for the *bbox_inches* parameter in `.Figure.savefig`.\n \"\"\"\n@@ -55,14 +56,14 @@ def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n \n     fig.bbox_inches = Bbox.from_bounds(0, 0, *bbox_inches.size)\n     x0, y0 = tr.transform(bbox_inches.p0)\n-    w1, h1 = fig.bbox.size * dpi_scale\n+    w1, h1 = bbox_inches.size  # Use the custom bbox_inches size directly\n     fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n     fig.transFigure.invalidate()\n \n     fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n \n-    fig.patch.set_bounds(x0 / w1, y0 / h1,\n-                         fig.bbox.width / w1, fig.bbox.height / h1)\n+    fig.patch.set_bounds(x0 / fig.dpi, y0 / fig.dpi,  # Adjust bounds based on custom bbox_inches\n+                         bbox_inches.width / fig.dpi, bbox_inches.height / fig.dpi)\n \n     return restore_bbox\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25640", "model_patch": "diff --git a/lib/matplotlib/backends/backend_pgf.py b/lib/matplotlib/backends/backend_pgf.py\nindex 2e88d0c..f6b8b18 100644\n--- a/lib/matplotlib/backends/backend_pgf.py\n+++ b/lib/matplotlib/backends/backend_pgf.py\n@@ -694,6 +694,9 @@ class RendererPgf(RendererBase):\n         if angle != 0:\n             text_args.append(\"rotate=%f\" % angle)\n \n+        # Add clipping to ensure the text is within the axis boundary\n+        clip_args = f\"clip=true, path bounding box={self.axes.bbox.transformed(self.figure.transFigure)}\"\n+        text_args.append(clip_args)\n         _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n         _writeln(self.fh, r\"\\end{pgfscope}\")\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25667", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 6a3d37e..6e63655 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2417,12 +2417,12 @@ class Axes(_AxesBase):\n \n         if orientation == 'vertical':\n             self._process_unit_info(\n-                [(\"x\", x), (\"y\", height)], kwargs, convert=False)\n+                [(\"x\", x), (\"y\", height), (\"bottom\", bottom)], kwargs, convert=False)\n             if log:\n                 self.set_yscale('log', nonpositive='clip')\n         else:  # horizontal\n             self._process_unit_info(\n-                [(\"x\", width), (\"y\", y)], kwargs, convert=False)\n+                [(\"x\", width), (\"y\", y), (\"left\", left)], kwargs, convert=False)\n             if log:\n                 self.set_xscale('log', nonpositive='clip')\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26078", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5537052..d125fa8 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1292,7 +1292,8 @@ class _AxesBase(martist.Artist):\n         self._tight = None\n         self._use_sticky_edges = True\n \n-        self._get_lines = _process_plot_var_args(self)\n+        import functools\n+        self._get_lines = functools.partial(_process_plot_var_args, self, axes=self)\n         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n \n         self._gridOn = mpl.rcParams['axes.grid']\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26466", "model_patch": "diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex a4bce05..6718704 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -1811,7 +1811,7 @@ or callable, default: value of *xycoords*\n \n         \"\"\"\n         _AnnotationBase.__init__(self,\n-                                 xy,\n+                                 xy.copy(),\n                                  xycoords=xycoords,\n                                  annotation_clip=annotation_clip)\n         # warn about wonky input data\n@@ -2028,4 +2028,4 @@ or callable, default: value of *xycoords*\n         return super().get_tightbbox(renderer)\n \n \n-_docstring.interpd.update(Annotation=Annotation.__init__.__doc__)\n+_docstring.interpd.update(Annotation=Annotation.__init__.__doc__)\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2576", "model_patch": "diff --git a/seaborn/regression.py b/seaborn/regression.py\nindex 0870277..0d1022b 100644\n--- a/seaborn/regression.py\n+++ b/seaborn/regression.py\n@@ -592,7 +592,8 @@ def lmplot(\n         palette=palette,\n         row_order=row_order, col_order=col_order, hue_order=hue_order,\n         height=height, aspect=aspect, col_wrap=col_wrap,\n-        sharex=sharex, sharey=sharey, legend_out=legend_out\n+        sharex=sharex, sharey=sharey, legend_out=legend_out,\n+        xlim=xlim, ylim=ylim\n     )\n \n     # Add the markers here as FacetGrid has figured out how many levels of the\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2846", "model_patch": "diff --git a/seaborn/_core/data.py b/seaborn/_core/data.py\nindex a66b99b..1b28a71 100644\n--- a/seaborn/_core/data.py\n+++ b/seaborn/_core/data.py\n@@ -250,6 +250,11 @@ class PlotData:\n                 # Try to infer the original name using pandas-like metadata\n                 if hasattr(val, \"name\"):\n                     names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424\n+                elif isinstance(val, np.ndarray):\n+                    # Convert numpy array to pandas Series and assign a name\n+                    series_name = f\"_{key}\" if key in variables else f\"_{id(val)}\"\n+                    plot_data[key] = pd.Series(val, name=series_name)\n+                    names[key] = ids[key] = series_name\n                 else:\n                     names[key] = None\n                     ids[key] = id(val)\n@@ -259,4 +264,4 @@ class PlotData:\n         # TODO Note: this fails when variable specs *only* have scalars!\n         frame = pd.DataFrame(plot_data)\n \n-        return frame, names, ids\n+        return frame, names, ids\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2979", "model_patch": "diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py\nindex 462e1e6..9d9ff22 100644\n--- a/seaborn/_core/subplots.py\n+++ b/seaborn/_core/subplots.py\n@@ -232,17 +232,17 @@ class Subplots:\n             elif self.wrap_dim == \"col\":\n                 info[\"left\"] = j % ncols == 0\n                 info[\"right\"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)\n-                info[\"top\"] = j < ncols\n-                info[\"bottom\"] = j >= (self.n_subplots - ncols)\n+                info[\"top\"] = j < self.wrap\n+                info[\"bottom\"] = j >= (self.n_subplots - self.wrap)\n             elif self.wrap_dim == \"row\":\n-                info[\"left\"] = i < nrows\n-                info[\"right\"] = i >= self.n_subplots - nrows\n+                info[\"left\"] = i < self.wrap\n+                info[\"right\"] = i >= (self.n_subplots - self.wrap)\n                 info[\"top\"] = i % nrows == 0\n                 info[\"bottom\"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)\n \n             if not pair_spec.get(\"cross\", True):\n-                info[\"top\"] = j < ncols\n-                info[\"bottom\"] = j >= self.n_subplots - ncols\n+                info[\"top\"] = j < self.wrap\n+                info[\"bottom\"] = j >= (self.n_subplots - self.wrap)\n \n             for dim in [\"row\", \"col\"]:\n                 idx = {\"row\": i, \"col\": j}[dim]\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3180", "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex f23fcd8..8c9d368 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -528,6 +528,9 @@ class FacetGrid(Grid):\n         if despine:\n             self.despine()\n \n+        # Adjust layout to prevent overlapping labels\n+        plt.subplots_adjust(hspace=0.5, wspace=0.5)\n+\n         if sharex in [True, 'col']:\n             for ax in self._not_bottom_axes:\n                 for label in ax.get_xticklabels():\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3187", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 609c102..c921cec 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -83,7 +83,10 @@ class Scale:\n     def _get_scale(self, name: str, forward: Callable, inverse: Callable):\n \n         major_locator, minor_locator = self._get_locators(**self._tick_params)\n-        major_formatter = self._get_formatter(major_locator, **self._label_params)\n+        import matplotlib as mpl\n+        use_offset = mpl.rcParams['axes.formatter.useoffset']\n+        offset_threshold = mpl.rcParams['axes.formatter.offset_threshold']\n+        major_formatter = self._get_formatter(major_locator, useOffset=use_offset, offsetThreshold=offset_threshold, **self._label_params)\n \n         class InternalScale(mpl.scale.FuncScale):\n             def set_default_locators_and_formatters(self, axis):\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3202", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 03cb23c..b86649c 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -207,11 +207,8 @@ class Nominal(Scale):\n \n         # TODO define this more centrally\n         def convert_units(x):\n-            # TODO only do this with explicit order?\n-            # (But also category dtype?)\n-            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)\n-            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)\n-            # keep = x.isin(units_seed)\n+            if len(x) == 0:\n+                return np.array([], dtype=float)\n             keep = np.array([x_ in units_seed for x_ in x], bool)\n             out = np.full(len(x), np.nan)\n             out[keep] = axis.convert_units(stringify(x[keep]))\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3216", "model_patch": "diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py\nindex d2a47ca..745115f 100644\n--- a/seaborn/_core/subplots.py\n+++ b/seaborn/_core/subplots.py\n@@ -183,7 +183,7 @@ class Subplots:\n             hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4\n             and isinstance(target, mpl.figure.SubFigure)\n         ):\n-            figure = target.figure\n+            figure = target\n         elif isinstance(target, mpl.figure.Figure):\n             figure = target\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3217", "model_patch": "diff --git a/seaborn/distributions.py b/seaborn/distributions.py\nindex 288f4e2..c26efdf 100644\n--- a/seaborn/distributions.py\n+++ b/seaborn/distributions.py\n@@ -489,8 +489,10 @@ class _DistributionPlotter(VectorPlotter):\n \n             # Convert edges back to original units for plotting\n             if self._log_scaled(self.data_variable):\n-                widths = np.power(10, edges + widths) - np.power(10, edges)\n-                edges = np.power(10, edges)\n+                log_edges = np.power(10, edges)\n+                log_widths = np.power(10, edges + widths) - log_edges\n+                widths = log_widths\n+                edges = log_edges\n \n             # Pack the histogram data and metadata together\n             edges = edges + (1 - shrink) / 2 * widths\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..8c1aef2 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -298,7 +298,7 @@ class _HeatMapper:\n \n         # setting vmin/vmax in addition to norm is deprecated\n         # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n+        if \"norm\" not in kws or kws[\"norm\"] is None:\n             kws.setdefault(\"vmin\", self.vmin)\n             kws.setdefault(\"vmax\", self.vmax)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3394", "model_patch": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex 88b4321..bdb2a79 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -392,7 +392,7 @@ class _LinePlotter(_RelationalPlotter):\n             if self.sort:\n                 sort_vars = [\"units\", orient, other]\n                 sort_cols = [var for var in sort_vars if var in self.variables]\n-                sub_data = sub_data.sort_values(sort_cols)\n+                sub_data = sub_data.sort_values(sort_cols, na_position='last')\n \n             if (\n                 self.estimator is not None\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..684afdf 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -184,7 +184,7 @@ def dim_section(obj):\n def array_section(obj):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n-    collapsed = \"\"\n+    collapsed = \"checked\"\n     variable = getattr(obj, \"variable\", obj)\n     preview = escape(inline_variable_array_repr(variable, max_width=70))\n     data_repr = short_data_repr_html(obj)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/plot/utils.py b/xarray/plot/utils.py\nindex 4a784fa..b51005e 100644\n--- a/xarray/plot/utils.py\n+++ b/xarray/plot/utils.py\n@@ -490,7 +490,10 @@ def label_from_attrs(da, extra=\"\"):\n     else:\n         units = _get_units_from_attrs(da)\n \n-    return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n+    if name.startswith(\"$\") and name.endswith(\"$\"):\n+        return name + extra + units\n+    else:\n+        return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n \n \n def _interval_to_mid_points(array):\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13087", "model_patch": "diff --git a/sklearn/calibration.py b/sklearn/calibration.py\nindex 142eda3..06f627e 100644\n--- a/sklearn/calibration.py\n+++ b/sklearn/calibration.py\n@@ -572,7 +572,8 @@ def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n \n     y_true = _check_binary_probabilistic_predictions(y_true, y_prob)\n \n-    bins = np.linspace(0., 1. + 1e-8, n_bins + 1)\n+    if bins is None:\n+        bins = np.linspace(0., 1. + 1e-8, n_bins + 1)\n     binids = np.digitize(y_prob, bins) - 1\n \n     bin_sums = np.bincount(binids, weights=y_prob, minlength=len(bins))\n@@ -583,4 +584,4 @@ def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n     prob_true = (bin_true[nonzero] / bin_total[nonzero])\n     prob_pred = (bin_sums[nonzero] / bin_total[nonzero])\n \n-    return prob_true, prob_pred\n+    return prob_true, prob_pred\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13618", "model_patch": "diff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\nindex 69c9741..06ff741 100644\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -157,7 +157,7 @@ class BayesianRidge(LinearModel, RegressorMixin):\n         self.copy_X = copy_X\n         self.verbose = verbose\n \n-    def fit(self, X, y, sample_weight=None):\n+    def fit(self, X, y, sample_weight=None, alpha_0=None, lambda_0=None):\n         \"\"\"Fit the model\n \n         Parameters\n@@ -173,6 +173,11 @@ class BayesianRidge(LinearModel, RegressorMixin):\n             .. versionadded:: 0.20\n                parameter *sample_weight* support to BayesianRidge.\n \n+        alpha_0 : float, optional\n+            Initial value for alpha. If None, it is set to 1. / (np.var(y) + eps).\n+        lambda_0 : float, optional\n+            Initial value for lambda. If None, it is set to 1.\n+\n         Returns\n         -------\n         self : returns an instance of self.\n@@ -199,8 +204,14 @@ class BayesianRidge(LinearModel, RegressorMixin):\n         eps = np.finfo(np.float64).eps\n         # Add `eps` in the denominator to omit division by zero if `np.var(y)`\n         # is zero\n-        alpha_ = 1. / (np.var(y) + eps)\n-        lambda_ = 1.\n+        if alpha_0 is None:\n+            alpha_ = 1. / (np.var(y) + eps)\n+        else:\n+            alpha_ = alpha_0\n+        if lambda_0 is None:\n+            lambda_ = 1.\n+        else:\n+            lambda_ = lambda_0\n \n         verbose = self.verbose\n         lambda_1 = self.lambda_1\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14067", "model_patch": "diff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\nindex d775ddb..0a19b0a 100644\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -552,7 +552,7 @@ class ARDRegression(LinearModel, RegressorMixin):\n \n         # Compute sigma and mu (using Woodbury matrix identity)\n         def update_sigma(X, alpha_, lambda_, keep_lambda, n_samples):\n-            sigma_ = pinvh(np.eye(n_samples) / alpha_ +\n+            sigma_ = np.linalg.pinv(np.eye(n_samples) / alpha_ +\n                            np.dot(X[:, keep_lambda] *\n                            np.reshape(1. / lambda_[keep_lambda], [1, -1]),\n                            X[:, keep_lambda].T))\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10048", "model_patch": "diff --git a/sphinx/writers/html5.py b/sphinx/writers/html5.py\nindex f949c89..95d2764 100644\n--- a/sphinx/writers/html5.py\n+++ b/sphinx/writers/html5.py\n@@ -320,7 +320,7 @@ class HTML5Translator(SphinxTranslator, BaseTranslator):\n     def add_permalink_ref(self, node: Element, title: str) -> None:\n         if node['ids'] and self.config.html_permalinks and self.builder.add_permalinks:\n             format = '<a class=\"headerlink\" href=\"#%s\" title=\"%s\">%s</a>'\n-            self.body.append(format % (node['ids'][0], title,\n+            self.body.append(format % (node['ids'][0], _(\"Permalink to this heading\"),\n                                        self.config.html_permalinks_icon))\n \n     # overwritten\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10191", "model_patch": "diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py\nindex 7e5e344..3131f5b 100644\n--- a/sphinx/builders/latex/transforms.py\n+++ b/sphinx/builders/latex/transforms.py\n@@ -436,12 +436,13 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):\n             footnote = self.appeared.get((docname, number))\n             footnote[\"referred\"] = True\n \n-            mark = footnotemark('', number, refid=node['refid'])\n+            # Ensure the refid is correctly set to the footnote's id\n+            mark = footnotemark('', number, refid=footnote['ids'][0])\n             node.replace_self(mark)\n         else:\n             footnote = self.get_footnote_by_reference(node)\n             if self.restricted:\n-                mark = footnotemark('', number, refid=node['refid'])\n+                mark = footnotemark('', number, refid=footnote['ids'][0])\n                 node.replace_self(mark)\n                 self.pendings.append(footnote)\n             else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10435", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 2dc462a..667ca17 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -721,10 +721,10 @@ class LaTeXTranslator(SphinxTranslator):\n         pass\n \n     def visit_desc_inline(self, node: Element) -> None:\n-        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+        self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n \n     def depart_desc_inline(self, node: Element) -> None:\n-        self.body.append('}}')\n+        self.body.append('}}%')\n \n     # Nodes for high-level structure in signatures\n     ##############################################\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11266", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 4b73f6a..ecf1c50 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -820,7 +820,7 @@ class LaTeXTranslator(SphinxTranslator):\n \n     def visit_seealso(self, node: Element) -> None:\n         self.body.append(BLANKLINE)\n-        self.body.append(r'\\begin{sphinxseealso}{%s}' % admonitionlabels['seealso'] + CR)\n+        self.body.append(r'\\begin{sphinxseealso}{%s }' % admonitionlabels['seealso'] + CR)\n \n     def depart_seealso(self, node: Element) -> None:\n         self.body.append(BLANKLINE)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..82f18a6 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,7 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for use by extensions.\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7615", "model_patch": "diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py\nindex 7aaad7b..233e3fd 100644\n--- a/sphinx/util/rst.py\n+++ b/sphinx/util/rst.py\n@@ -38,7 +38,8 @@ WIDECHARS[\"ja\"] = \"WFA\"  # In Japanese, Ambiguous characters also have double wi\n \n \n def escape(text: str) -> str:\n-    text = symbols_re.sub(r'\\\\\\1', text)\n+    # Modify the regex to exclude backslashes from being escaped additional times\n+    text = symbols_re.sub(lambda match: '\\\\' + match.group(1) if match.group(1) != '\\\\' else match.group(1), text)\n     text = re.sub(r'^\\.', r'\\.', text)  # escape a dot at top\n     return text\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7757", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 3555587..654e5b0 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -178,7 +178,7 @@ def _parse_arglist(arglist: str) -> addnodes.desc_parameterlist:\n                 node += nodes.Text(' ')\n             else:\n                 node += addnodes.desc_sig_operator('', '=')\n-            node += nodes.inline('', param.default, classes=['default_value'],\n+            node += nodes.inline('', str(param.default), classes=['default_value'],\n                                  support_smartquotes=False)\n \n         params += node\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8028", "model_patch": "diff --git a/sphinx/ext/autosummary/generate.py b/sphinx/ext/autosummary/generate.py\nindex ec986a0..6a306bb 100644\n--- a/sphinx/ext/autosummary/generate.py\n+++ b/sphinx/ext/autosummary/generate.py\n@@ -184,10 +184,16 @@ class ModuleScanner:\n         self.object = obj\n \n     def get_object_type(self, name: str, value: Any) -> str:\n+        if isinstance(value, property):\n+            # Recognize instance attributes as 'attribute'\n+            return 'attribute'\n         return get_documenter(self.app, value, self.object).objtype\n \n     def is_skipped(self, name: str, value: Any, objtype: str) -> bool:\n         try:\n+            if objtype == 'attribute' and isinstance(value, property):\n+                # Ensure instance attributes are not skipped\n+                return False\n             return self.app.emit_firstresult('autodoc-skip-member', objtype,\n                                              name, value, False, {})\n         except Exception as exc:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8056", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex f955f19..6ff8b98 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1083,7 +1083,22 @@ class NumpyDocstring(GoogleDocstring):\n         func = super()._escape_args_and_kwargs\n \n         if \", \" in name:\n-            return \", \".join(func(param) for param in name.split(\", \"))\n+            # Split the name and type separately\n+            name_parts = name.split(\", \")\n+            # Check if the last part contains 'optional'\n+            if 'optional' in name_parts[-1]:\n+                name_parts[-1] = name_parts[-1].replace('optional', '').strip()\n+                optional = True\n+            else:\n+                optional = False\n+            # Escape each parameter name\n+            escaped_names = [func(param) for param in name_parts]\n+            # Join the names back together\n+            escaped_name = \", \".join(escaped_names)\n+            # Add 'optional' back if it was present\n+            if optional:\n+                escaped_name += ', optional'\n+            return escaped_name\n         else:\n             return func(name)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8075", "model_patch": "diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py\nindex 5d338ec..ab36cc4 100644\n--- a/sphinx/builders/latex/transforms.py\n+++ b/sphinx/builders/latex/transforms.py\n@@ -389,6 +389,10 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):\n             self.pendings = []\n \n     def visit_figure(self, node: nodes.figure) -> None:\n+        if not node.caption:\n+            # Add a default caption for LaTeX\n+            default_caption = nodes.caption('', nodes.Text(f'Figure {self.document.settings.figure_number}'))\n+            node.append(default_caption)\n         self.restrict(node)\n \n     def depart_figure(self, node: nodes.figure) -> None:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8120", "model_patch": "diff --git a/sphinx/config.py b/sphinx/config.py\nindex fbf72e8..7a4bd3f 100644\n--- a/sphinx/config.py\n+++ b/sphinx/config.py\n@@ -107,7 +107,7 @@ class Config:\n         'today_fmt': (None, 'env', [str]),\n \n         'language': (None, 'env', [str]),\n-        'locale_dirs': (['locales'], 'env', []),\n+        'locale_dirs': ([], 'env', []),\n         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n \n         'master_doc': ('index', 'env', []),\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8265", "model_patch": "diff --git a/doc/conf.py b/doc/conf.py\nindex 12fe8fb..fa41719 100644\n--- a/doc/conf.py\n+++ b/doc/conf.py\n@@ -83,6 +83,12 @@ latex_show_urls = 'footnote'\n latex_use_xindy = True\n \n autodoc_member_order = 'groupwise'\n+autodoc_default_options = {\n+    'members': True,\n+    'undoc-members': True,\n+    'show-inheritance': True,\n+    'member-order': 'bysource',\n+}\n todo_include_todos = True\n extlinks = {'duref': ('http://docutils.sourceforge.net/docs/ref/rst/'\n                       'restructuredtext.html#%s', ''),\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8278", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 71b6f3a..02d10b3 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -196,12 +196,19 @@ def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_\n             node += nodes.Text(' ')\n             node += addnodes.desc_sig_name('', '', *children)  # type: ignore\n         if param.default is not param.empty:\n+            import ast\n             if param.annotation is not param.empty:\n                 node += nodes.Text(' ')\n                 node += addnodes.desc_sig_operator('', '=')\n                 node += nodes.Text(' ')\n             else:\n                 node += addnodes.desc_sig_operator('', '=')\n+            try:\n+                default_value = ast.literal_eval(param.default)\n+                if isinstance(default_value, int) and param.default.startswith('0x'):\n+                    param.default = hex(default_value)\n+            except (ValueError, SyntaxError):\n+                pass\n             node += nodes.inline('', param.default, classes=['default_value'],\n                                  support_smartquotes=False)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8620", "model_patch": "diff --git a/sphinx/writers/html.py b/sphinx/writers/html.py\nindex 30db1c2..fac630d 100644\n--- a/sphinx/writers/html.py\n+++ b/sphinx/writers/html.py\n@@ -494,8 +494,13 @@ class HTMLTranslator(SphinxTranslator, BaseTranslator):\n     # overwritten\n     def visit_literal(self, node: Element) -> None:\n         if 'kbd' in node['classes']:\n-            self.body.append(self.starttag(node, 'kbd', '',\n-                                           CLASS='docutils literal notranslate'))\n+            # Check if the node contains '+', indicating a compound key\n+            if '+' in node.astext():\n+                self.body.append(self.starttag(node, 'kbd', '',\n+                                               CLASS='kbd compound docutils literal notranslate'))\n+            else:\n+                self.body.append(self.starttag(node, 'kbd', '',\n+                                               CLASS='kbd docutils literal notranslate'))\n         else:\n             self.body.append(self.starttag(node, 'code', '',\n                                            CLASS='docutils literal notranslate'))\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8621", "model_patch": "diff --git a/sphinx/writers/html.py b/sphinx/writers/html.py\nindex 30db1c2..71cfc14 100644\n--- a/sphinx/writers/html.py\n+++ b/sphinx/writers/html.py\n@@ -676,7 +676,7 @@ class HTMLTranslator(SphinxTranslator, BaseTranslator):\n     def visit_Text(self, node: Text) -> None:\n         text = node.astext()\n         encoded = self.encode(text)\n-        if self.protect_literal_text:\n+        if self.protect_literal_text and 'kbd' not in node.parent['classes']:\n             # moved here from base class's visit_literal to support\n             # more formatting in literal nodes\n             for token in self.words_and_spaces.findall(encoded):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex f9408ce..568f014 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -300,7 +300,7 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n                 analyzer = ModuleAnalyzer.for_module(modname)\n                 analyzer.analyze()\n                 for (ns, name), docstring in analyzer.attr_docs.items():\n-                    if ns == qualname and name not in members:\n+                    if ns.startswith(qualname) and name not in members:\n                         members[name] = ObjectMember(name, INSTANCEATTR, class_=cls,\n                                                      docstring='\\n'.join(docstring))\n             except (AttributeError, PycodeError):\n@@ -308,4 +308,4 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n     except AttributeError:\n         pass\n \n-    return members\n+    return members\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8658", "model_patch": "diff --git a/sphinx/ext/napoleon/__init__.py b/sphinx/ext/napoleon/__init__.py\nindex 94d9c8c..e89c666 100644\n--- a/sphinx/ext/napoleon/__init__.py\n+++ b/sphinx/ext/napoleon/__init__.py\n@@ -279,6 +279,7 @@ class Config:\n         'napoleon_preprocess_types': (False, 'env'),\n         'napoleon_type_aliases': (None, 'env'),\n         'napoleon_custom_sections': (None, 'env'),\n+        'napoleon_custom_section_rename': (True, 'env'),  # True is default for backwards compatibility.\n         'napoleon_attr_annotations': (True, 'env'),\n     }\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9229", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex b8c505d..86565cf 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1369,8 +1369,9 @@ def builtin_resolver(app: Sphinx, env: BuildEnvironment,\n \n     if node.get('refdomain') != 'py':\n         return None\n-    elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n-        return contnode\n+    # Removed the condition that ignores the docstring when reftarget is None\n+    # elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n+    #     return contnode\n     elif node.get('reftype') in ('class', 'exc'):\n         reftarget = node.get('reftarget')\n         if inspect.isclass(getattr(builtins, reftarget, None)):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9230", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..dfe33e9 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -818,7 +818,7 @@ class GoogleDocstring:\n                     found_colon = True\n                     colon = source[m.start(): m.end()]\n                     before_colon.append(source[:m.start()])\n-                    after_colon.append(source[m.end():])\n+                    after_colon.append(source[m.end():].strip())\n                 else:\n                     before_colon.append(source)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9289", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 138f6bb..fa7c9f5 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -110,7 +110,10 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n     \"\"\"Parse type annotation.\"\"\"\n     def unparse(node: ast.AST) -> List[Node]:\n         if isinstance(node, ast.Attribute):\n-            return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n+            if env.config.python_use_unqualified_type_names:\n+                return [nodes.Text(node.attr)]\n+            else:\n+                return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n         elif isinstance(node, ast.BinOp):\n             result: List[Node] = unparse(node.left)\n             result.extend(unparse(node.op))\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..fc511ce 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', allow_empty)\n         if not d['path']:\n             sys.exit(1)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9350", "model_patch": "diff --git a/sphinx/writers/manpage.py b/sphinx/writers/manpage.py\nindex ef44f6d..2f23119 100644\n--- a/sphinx/writers/manpage.py\n+++ b/sphinx/writers/manpage.py\n@@ -442,10 +442,16 @@ class ManualPageTranslator(SphinxTranslator, BaseTranslator):\n         raise nodes.SkipNode\n \n     def visit_inline(self, node: Element) -> None:\n-        pass\n+        # Check if the inline node has the 'samp' role\n+        if 'samp' in node.get('classes', []):\n+            # Start the samp formatting\n+            self.body.append('.B ')\n \n     def depart_inline(self, node: Element) -> None:\n-        pass\n+        # Check if the inline node has the 'samp' role\n+        if 'samp' in node.get('classes', []):\n+            # End the samp formatting\n+            self.body.append('\\n')\n \n     def visit_math(self, node: Element) -> None:\n         pass\n@@ -460,4 +466,4 @@ class ManualPageTranslator(SphinxTranslator, BaseTranslator):\n         self.depart_centered(node)\n \n     def unknown_visit(self, node: Node) -> None:\n-        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)\n+        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9464", "model_patch": "diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\nindex 7d0ed59..c5dacc0 100644\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -337,6 +337,9 @@ def _stringify_py37(annotation: Any) -> str:\n     elif hasattr(annotation, '__origin__'):\n         # instantiated generic provided by a user\n         qualname = stringify(annotation.__origin__)\n+        if getattr(annotation, '__args__', None):\n+            args = ', '.join(stringify(a) for a in annotation.__args__)\n+            return '%s[%s]' % (qualname, args)\n     elif types_Union and isinstance(annotation, types_Union):  # types.Union (for py3.10+)\n         qualname = 'types.Union'\n     else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9673", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 51811ca..ac1b18c 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -64,7 +64,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             if app.config.autodoc_typehints_description_target == \"all\":\n                 modify_field_list(field_list, annotations[fullname])\n             else:\n-                augment_descriptions_with_types(field_list, annotations[fullname])\n+                augment_descriptions_with_types(app, field_list, annotations[fullname])\n \n \n def insert_field_list(node: Element) -> nodes.field_list:\n@@ -128,6 +128,7 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n \n \n def augment_descriptions_with_types(\n+    app: Sphinx,\n     node: nodes.field_list,\n     annotations: Dict[str, str],\n ) -> None:\n@@ -166,11 +167,18 @@ def augment_descriptions_with_types(\n \n     # Add 'rtype' if 'return' is present and 'rtype' isn't.\n     if 'return' in annotations:\n-        if 'return' in has_description and 'return' not in has_type:\n-            field = nodes.field()\n-            field += nodes.field_name('', 'rtype')\n-            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n-            node += field\n+        if app.config.autodoc_typehints_description_target == \"documented\":\n+            if 'return' in has_description and 'return' not in has_type:\n+                field = nodes.field()\n+                field += nodes.field_name('', 'rtype')\n+                field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+                node += field\n+        elif app.config.autodoc_typehints_description_target == \"all\":\n+            if 'return' not in has_type:\n+                field = nodes.field()\n+                field += nodes.field_name('', 'rtype')\n+                field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+                node += field\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9797", "model_patch": "diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex cb48248..0e44eaf 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -280,10 +280,16 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n \n             unmangled = unmangle(subject, name)\n             if unmangled and unmangled not in members:\n-                if name in obj_dict:\n-                    members[unmangled] = ObjectMember(unmangled, value, class_=subject)\n+                if unmangled in obj_dict and obj_dict[unmangled].__doc__ is None:\n+                    # Find the docstring in the MRO if it is not present in the class\n+                    for cls in getmro(subject):\n+                        if unmangled in cls.__dict__ and cls.__dict__[unmangled].__doc__ is not None:\n+                            members[unmangled] = ObjectMember(unmangled, value, class_=cls, docstring=cls.__dict__[unmangled].__doc__)\n+                            break\n+                    else:\n+                        members[unmangled] = ObjectMember(unmangled, value)\n                 else:\n-                    members[unmangled] = ObjectMember(unmangled, value)\n+                    members[unmangled] = ObjectMember(unmangled, value, class_=subject)\n         except AttributeError:\n             continue\n \n@@ -321,4 +327,4 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n     except AttributeError:\n         pass\n \n-    return members\n+    return members\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9982", "model_patch": "diff --git a/sphinx/util/logging.py b/sphinx/util/logging.py\nindex 2c96388..67c9f44 100644\n--- a/sphinx/util/logging.py\n+++ b/sphinx/util/logging.py\n@@ -49,7 +49,7 @@ VERBOSITY_MAP.update({\n COLOR_MAP = defaultdict(lambda: 'blue',\n                         {\n                             logging.ERROR: 'darkred',\n-                            logging.WARNING: 'red',\n+                            logging.WARNING: 'lightred',\n                             logging.DEBUG: 'darkgray'\n                         })\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9987", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..b14d200 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -268,6 +268,12 @@ class GoogleDocstring:\n             if match:\n                 _name = match.group(1).strip()\n                 _type = match.group(2)\n+            else:\n+                # Handle position-only parameters\n+                match = _google_typed_arg_regex.match(after)\n+                if match:\n+                    _name = match.group(1).strip()\n+                    _type = match.group(2)\n \n         _name = self._escape_args_and_kwargs(_name)\n \n@@ -619,7 +625,7 @@ class GoogleDocstring:\n         return self._format_admonition(admonition, lines)\n \n     def _parse_attribute_docstring(self) -> List[str]:\n-        _type, _desc = self._consume_inline_attribute()\n+        _type, _desc = self._consume_field(parse_type=True, prefer_type=False)\n         lines = self._format_field('', '', _desc)\n         if _type:\n             lines.extend(['', ':type: %s' % _type])\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9997", "model_patch": "diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\nindex 9e4d85e..179dfd1 100644\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -185,7 +185,8 @@ def _restify_py37(cls: Optional[Type]) -> str:\n             args = ', '.join(restify(a) for a in cls.__args__[:-1])\n             text += r\"\\ [[%s], %s]\" % (args, restify(cls.__args__[-1]))\n         elif cls.__module__ == 'typing' and getattr(origin, '_name', None) == 'Literal':\n-            text += r\"\\ [%s]\" % ', '.join(repr(a) for a in cls.__args__)\n+            args = ', '.join(restify(a) for a in cls.__args__)\n+            text += r\"\\ [%s]\" % args\n         elif cls.__args__:\n             text += r\"\\ [%s]\" % \", \".join(restify(a) for a in cls.__args__)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9999", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 08c7588..155ecc5 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -1092,7 +1092,7 @@ class LaTeXTranslator(SphinxTranslator):\n             ctx = r'\\phantomsection'\n             for node_id in node['ids']:\n                 ctx += self.hypertarget(node_id, anchor=False)\n-        ctx += r'}] \\leavevmode'\n+        ctx += r'}] \\leavevmode' + CR\n         self.body.append(r'\\item[{')\n         self.context.append(ctx)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11787", "model_patch": "diff --git a/sympy/solvers/solvers.py b/sympy/solvers/solvers.py\nindex 60703ea..5cc9eaa 100644\n--- a/sympy/solvers/solvers.py\n+++ b/sympy/solvers/solvers.py\n@@ -2762,7 +2762,7 @@ def nsolve(*args, **kwargs):\n                 expected a one-dimensional and numerical function'''))\n \n         # the function is much better behaved if there is no denominator\n-        f = f.as_numer_denom()[0]\n+        # f = f.as_numer_denom()[0]\n \n         f = lambdify(fargs, f, modules)\n         return Float(findroot(f, x0, **kwargs))\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d19d26f..5ecd95a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1452,7 +1452,7 @@ class LatexPrinter(Printer):\n     def _print_SingularityFunction(self, expr):\n         shift = self._print(expr.args[0] - expr.args[1])\n         power = self._print(expr.args[2])\n-        tex = r\"{\\langle %s \\rangle}^ %s\" % (shift, power)\n+        tex = r\"{\\langle %s \\rangle}^{%s}\" % (shift, power)\n         return tex\n \n     def _print_Heaviside(self, expr, exp=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13840", "model_patch": "diff --git a/sympy/printing/jscode.py b/sympy/printing/jscode.py\nindex 94518b8..54d1d87 100644\n--- a/sympy/printing/jscode.py\n+++ b/sympy/printing/jscode.py\n@@ -108,6 +108,12 @@ class JavascriptCodePrinter(CodePrinter):\n             return 'Math.pow(%s, %s)' % (self._print(expr.base),\n                                  self._print(expr.exp))\n \n+    def _print_Max(self, expr):\n+        return 'Math.max(%s)' % ', '.join(self._print(arg) for arg in expr.args)\n+\n+    def _print_Min(self, expr):\n+        return 'Math.min(%s)' % ', '.join(self._print(arg) for arg in expr.args)\n+\n     def _print_Rational(self, expr):\n         p, q = int(expr.p), int(expr.q)\n         return '%d/%d' % (p, q)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15151", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 5a58eb3..eb22e8d 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -610,8 +610,10 @@ class LatexPrinter(Printer):\n         return outstr\n \n     def _print_Indexed(self, expr):\n-        tex = self._print(expr.base)+'_{%s}' % ','.join(\n-            map(self._print, expr.indices))\n+        if len(expr.indices) == 1:\n+            tex = self._print(expr.base) + '_{%s}' % self._print(expr.indices[0])\n+        else:\n+            tex = self._print(expr.base) + '_{%s}' % ','.join(map(self._print, expr.indices))\n         return tex\n \n     def _print_IndexedBase(self, expr):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15304", "model_patch": "diff --git a/sympy/physics/continuum_mechanics/beam.py b/sympy/physics/continuum_mechanics/beam.py\nindex 4907451..e88128a 100644\n--- a/sympy/physics/continuum_mechanics/beam.py\n+++ b/sympy/physics/continuum_mechanics/beam.py\n@@ -395,8 +395,10 @@ class Beam(object):\n                 self._load -= value*SingularityFunction(x, end, order)\n             elif order.is_positive:\n                 self._load -= value*SingularityFunction(x, end, order) + value*SingularityFunction(x, end, 0)\n+            elif order.is_negative:\n+                self._load -= value*SingularityFunction(x, end, order)\n             else:\n-                raise ValueError(\"\"\"Order of the load should be positive.\"\"\")\n+                raise ValueError(\"\"\"Order of the load should be an integer.\"\"\")\n \n     def remove_load(self, value, start, order, end=None):\n         \"\"\"\n@@ -717,10 +719,14 @@ class Beam(object):\n \n         solution = list((linsolve([shear_curve, moment_curve] + slope_eqs\n                             + deflection_eqs, (C3, C4) + reactions).args)[0])\n+        print(\"Solution:\", solution)\n         solution = solution[2:]\n+        print(\"Reaction Loads:\", dict(zip(reactions, solution)))\n \n         self._reaction_loads = dict(zip(reactions, solution))\n+        print(\"Reaction Loads:\", self._reaction_loads)\n         self._load = self._load.subs(self._reaction_loads)\n+        print(\"Updated Load:\", self._load)\n \n     def shear_force(self):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15625", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 9bda2d6..cf9b2b8 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -195,7 +195,10 @@ class LatexPrinter(Printer):\n             return r\"$$%s$$\" % tex\n         else:\n             env_str = self._settings['mode']\n-            return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n+            if env_str == 'equation*':\n+                return r\"$\\displaystyle %s$\" % tex\n+            else:\n+                return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n \n     def _needs_brackets(self, expr):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15976", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 85af872..964cb63 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -779,26 +779,22 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n \n         mname = self.dom.createElement('mi')\n         mname.appendChild(self.dom.createTextNode(name))\n-        if len(supers) == 0:\n-            if len(subs) == 0:\n-                x.appendChild(self.dom.createTextNode(name))\n-            else:\n+        if len(supers) == 0 and len(subs) == 0:\n+            x.appendChild(self.dom.createTextNode(name))\n+        else:\n+            mrow = self.dom.createElement('mrow')\n+            mrow.appendChild(mname)\n+            if len(subs) > 0:\n                 msub = self.dom.createElement('msub')\n-                msub.appendChild(mname)\n+                msub.appendChild(mrow)\n                 msub.appendChild(join(subs))\n-                x.appendChild(msub)\n-        else:\n-            if len(subs) == 0:\n+                mrow = msub\n+            if len(supers) > 0:\n                 msup = self.dom.createElement('msup')\n-                msup.appendChild(mname)\n+                msup.appendChild(mrow)\n                 msup.appendChild(join(supers))\n-                x.appendChild(msup)\n-            else:\n-                msubsup = self.dom.createElement('msubsup')\n-                msubsup.appendChild(mname)\n-                msubsup.appendChild(join(subs))\n-                msubsup.appendChild(join(supers))\n-                x.appendChild(msubsup)\n+                mrow = msup\n+            x.appendChild(mrow)\n         return x\n \n     def _print_MatrixSymbol(self, sym):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16003", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 85af872..815833d 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -843,33 +843,49 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n         x = self.dom.createElement('mo')\n         if requires_partial(e):\n             x.appendChild(self.dom.createTextNode('&#x2202;'))\n-            y = self.dom.createElement('mo')\n-            y.appendChild(self.dom.createTextNode('&#x2202;'))\n         else:\n             x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            y = self.dom.createElement('mo')\n-            y.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n \n         brac = self.dom.createElement('mfenced')\n         brac.appendChild(self._print(e.expr))\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(x)\n         mrow.appendChild(brac)\n \n-        for sym in e.variables:\n-            frac = self.dom.createElement('mfrac')\n-            m = self.dom.createElement('mrow')\n-            x = self.dom.createElement('mo')\n-            if requires_partial(e):\n-                x.appendChild(self.dom.createTextNode('&#x2202;'))\n+        if requires_partial(e):\n+            deriv_symbol = '&#x2202;'\n+        else:\n+            deriv_symbol = 'd'\n+\n+        numerator = self.dom.createElement('mrow')\n+        denominator = self.dom.createElement('mrow')\n+        dim = 0\n+        for sym, num in reversed(e.variable_count):\n+            dim += num\n+            mo = self.dom.createElement('mo')\n+            mo.appendChild(self.dom.createTextNode(deriv_symbol))\n+            numerator.appendChild(mo)\n+\n+            if num == 1:\n+                denominator.appendChild(self._print(sym))\n             else:\n-                x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            y = self._print(sym)\n-            m.appendChild(x)\n-            m.appendChild(y)\n-            frac.appendChild(mrow)\n-            frac.appendChild(m)\n-            mrow = frac\n+                mo_sup = self.dom.createElement('msup')\n+                mo_sup.appendChild(self._print(sym))\n+                mo_sup.appendChild(self._print(num))\n+                denominator.appendChild(mo_sup)\n+\n+        if dim > 1:\n+            mo_sup = self.dom.createElement('msup')\n+            mo_sup.appendChild(x)\n+            mo_sup.appendChild(self.dom.createElement('mn').appendChild(self.dom.createTextNode(str(dim))))\n+            numerator = mo_sup\n+\n+        frac = self.dom.createElement('mfrac')\n+        frac.appendChild(numerator)\n+        frac.appendChild(denominator)\n+\n+        # Place the function on a separate line if there are multiple derivatives\n+        if dim > 1 or len(e.variable_count) > 1:\n+            mrow.appendChild(self.dom.createElement('mspace').setAttribute('linebreak', 'newline'))\n+            mrow.appendChild(self._print(e.expr))\n \n         return frac\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17067", "model_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 73bbc98..ae3013d 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -479,7 +479,7 @@ def trigsimp(expr, **opts):\n     if not old:\n         opts.pop('deep', None)\n         opts.pop('recursive', None)\n-        method = opts.pop('method', 'matching')\n+        method = opts.pop('method', 'fu')\n     else:\n         method = 'old'\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17115", "model_patch": "diff --git a/sympy/functions/elementary/piecewise.py b/sympy/functions/elementary/piecewise.py\nindex 2558a3b..532ed69 100644\n--- a/sympy/functions/elementary/piecewise.py\n+++ b/sympy/functions/elementary/piecewise.py\n@@ -176,7 +176,7 @@ class Piecewise(Function):\n         # make conditions canonical\n         args = []\n         for e, c in _args:\n-            if not c.is_Atom and not isinstance(c, Relational):\n+            if not c.is_Atom and not isinstance(c, Boolean):\n                 free = c.free_symbols\n                 if len(free) == 1:\n                     funcs = [i for i in c.atoms(Function)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18922", "model_patch": "diff --git a/sympy/plotting/plot.py b/sympy/plotting/plot.py\nindex cce65e7..87c872d 100644\n--- a/sympy/plotting/plot.py\n+++ b/sympy/plotting/plot.py\n@@ -1167,8 +1167,10 @@ class MatplotlibBackend(BaseBackend):\n                 ax.spines['left'].set_position(pos_left)\n                 ax.spines['bottom'].set_position(pos_bottom)\n             else:\n-                ax.spines['left'].set_position(('data', val[0]))\n-                ax.spines['bottom'].set_position(('data', val[1]))\n+                if val[0] is not None:\n+                    ax.spines['left'].set_position(('data', val[0]))\n+                if val[1] is not None:\n+                    ax.spines['bottom'].set_position(('data', val[1]))\n         if not parent.axis:\n             ax.set_axis_off()\n         if parent.legend:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21769", "model_patch": "diff --git a/sympy/physics/quantum/cg.py b/sympy/physics/quantum/cg.py\nindex ae6b99a..444861f 100644\n--- a/sympy/physics/quantum/cg.py\n+++ b/sympy/physics/quantum/cg.py\n@@ -218,7 +218,7 @@ class CG(Wigner3j):\n     def _latex(self, printer, *args):\n         label = map(printer._print, (self.j3, self.m3, self.j1,\n                     self.m1, self.j2, self.m2))\n-        return r'C^{%s,%s}_{%s,%s,%s,%s}' % tuple(label)\n+        return r'{C^{%s,%s}_{%s,%s,%s,%s}}' % tuple(label)\n \n \n class Wigner6j(Expr):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-4083", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex a2d5367..80040c8 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -2078,7 +2078,7 @@ def make_figure(args, constructor, trace_patch=None, layout_patch=None):\n                 val = group_name[i]\n                 try:\n                     m.updater(trace, m.val_map[val])  # covers most cases\n-                except ValueError:\n+                except ValueError as e:\n                     # this catches some odd cases like marginals\n                     if (\n                         trace_spec != trace_specs[0]\n@@ -2108,8 +2108,10 @@ def make_figure(args, constructor, trace_patch=None, layout_patch=None):\n                             showscale=False,\n                             showlegend=True,\n                         )\n+                    elif m.variable == \"hover_data\" and isinstance(m.val_map[val], str):\n+                        raise ValueError(f\"Looks like you supplied a single column name, you should supply a list of columns. Expected one of {list(args['data_frame'].columns)} but received: {m.val_map[val]}\")\n                     else:\n-                        raise\n+                        raise e\n \n                 # Find row for trace, handling facet_row and marginal_x\n                 if m.facet == \"row\":\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-2600", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 723f514..823ebad 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -535,7 +535,9 @@ def configure_cartesian_marginal_axes(args, fig, orders):\n \n     # Set y-axis titles and axis options in the left-most column\n     for yaxis in fig.select_yaxes(col=1):\n-        set_cartesian_axis_opts(args, yaxis, \"y\", orders)\n+        args_without_range_y = args.copy()\n+        args_without_range_y.pop(\"range_y\", None)\n+        set_cartesian_axis_opts(args_without_range_y, yaxis, \"y\", orders)\n \n     # Set x-axis titles and axis options in the bottom-most row\n     for xaxis in fig.select_xaxes(row=1):\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-2591", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 8ada692..4066b3a 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1507,7 +1507,10 @@ def process_dataframe_hierarchy(args):\n \n         if args[\"color\"]:\n             if args[\"color\"] == args[\"values\"]:\n-                aggfunc_color = \"sum\"\n+                def aggfunc_continuous(x):\n+                    return np.average(x, weights=df.loc[x.index, count_colname])\n+\n+                aggfunc_color = aggfunc_continuous\n         count_colname = args[\"values\"]\n     else:\n         # we need a count column for the first groupby and the weighted mean of color\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-1966", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 897ecfd..b873583 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1267,7 +1267,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"row\":\n                     row = m.val_map[val]\n                     if args[\"facet_row\"] and len(row_labels) < row:\n-                        row_labels.append(args[\"facet_row\"] + \"=\" + str(val))\n+                        row_labels.append(get_decorated_label(args, args[\"facet_row\"], \"facet_row\") + \"=\" + str(val))\n                 else:\n                     if (\n                         bool(args.get(\"marginal_x\", False))\n@@ -1282,7 +1282,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"col\":\n                     col = m.val_map[val]\n                     if args[\"facet_col\"] and len(col_labels) < col:\n-                        col_labels.append(args[\"facet_col\"] + \"=\" + str(val))\n+                        col_labels.append(get_decorated_label(args, args[\"facet_col\"], \"facet_col\") + \"=\" + str(val))\n                     if facet_col_wrap:  # assumes no facet_row, no marginals\n                         row = 1 + ((col - 1) // facet_col_wrap)\n                         col = 1 + ((col - 1) % facet_col_wrap)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6503", "model_patch": "diff --git a/networkx/algorithms/tree/operations.py b/networkx/algorithms/tree/operations.py\nindex dfa8a5c..120cb67 100644\n--- a/networkx/algorithms/tree/operations.py\n+++ b/networkx/algorithms/tree/operations.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Operations on trees.\"\"\"\n from functools import partial\n from itertools import accumulate, chain\n@@ -82,10 +83,11 @@ def join(rooted_trees, label_attribute=None):\n         for tree, root in zip(trees, roots)\n     ]\n \n-    # Remove the old node labels.\n-    for tree in trees:\n-        for v in tree:\n-            tree.nodes[v].pop(\"_old\")\n+    # Remove the old node labels only if label_attribute is None.\n+    if label_attribute is None:\n+        for tree in trees:\n+            for v in tree:\n+                tree.nodes[v].pop(\"_old\")\n \n     # Add all sets of nodes and edges, with data.\n     nodes = (tree.nodes(data=True) for tree in trees)\n@@ -103,4 +105,4 @@ def join(rooted_trees, label_attribute=None):\n     R.add_node(0)\n     R.add_edges_from((0, root) for root in roots)\n \n-    return R\n+    return R\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6098", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 563968a..43e7e2d 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -657,9 +657,9 @@ def draw_networkx_edges(\n         else:\n             arrowstyle = \"-\"\n \n-    use_linecollection = not G.is_directed()\n+    use_linecollection = not G.is_directed() and connectionstyle == \"arc3\"\n     if arrows in (True, False):\n-        use_linecollection = not arrows\n+        use_linecollection = not arrows and connectionstyle == \"arc3\"\n \n     if ax is None:\n         ax = plt.gca()\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5616", "model_patch": "diff --git a/networkx/algorithms/euler.py b/networkx/algorithms/euler.py\nindex 5b844cf..7585e75 100644\n--- a/networkx/algorithms/euler.py\n+++ b/networkx/algorithms/euler.py\n@@ -287,6 +287,12 @@ def has_eulerian_path(G, source=None):\n             unbalanced_ins <= 1 and unbalanced_outs <= 1 and nx.is_weakly_connected(G)\n         )\n     else:\n+        # Remove isolated nodes (if any) without altering the input graph\n+        nodes_remove = [v for v in G if G.degree[v] == 0]\n+        if nodes_remove:\n+            G = G.copy()\n+            G.remove_nodes_from(nodes_remove)\n+        \n         # We know it is not eulerian, so degree of source must be odd.\n         if source is not None and G.degree[source] % 2 != 1:\n             return False\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5058", "model_patch": "diff --git a/networkx/readwrite/graphml.py b/networkx/readwrite/graphml.py\nindex 523e516..8b54924 100644\n--- a/networkx/readwrite/graphml.py\n+++ b/networkx/readwrite/graphml.py\n@@ -548,9 +548,14 @@ class GraphMLWriter(GraphML):\n         type in the keys table.\n         \"\"\"\n         if element_type not in self.xml_type:\n-            raise nx.NetworkXError(\n-                f\"GraphML writer does not support {element_type} as data values.\"\n-            )\n+            # Convert unsupported types to strings\n+            if isinstance(value, (list, tuple, set, dict)):\n+                value = str(value)\n+                element_type = self.xml_type['string']\n+            else:\n+                raise nx.NetworkXError(\n+                    f\"GraphML writer does not support {element_type} as data values.\"\n+                )\n         keyid = self.get_key(name, self.xml_type[element_type], scope, default)\n         data_element = self.myElement(\"data\", key=keyid)\n         data_element.text = str(value)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..95e8a3b 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -565,6 +565,9 @@ def draw_networkx_edges(\n     min_target_margin : int, optional (default=0)\n        The minimum margin (gap) at the end of the edge at the target.\n \n+    nodelist : list, optional (default=G.nodes())\n+       Draw only edges that are incident to nodes in this list.\n+\n     Returns\n     -------\n     list of matplotlib.patches.FancyArrowPatch\n@@ -633,6 +636,9 @@ def draw_networkx_edges(\n \n     if nodelist is None:\n         nodelist = list(G.nodes())\n+    else:\n+        # Filter edgelist to only include edges incident on nodes in nodelist\n+        edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n \n     # FancyArrowPatch handles color=None different from LineCollection\n     if edge_color is None:\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-3764", "model_patch": "diff --git a/networkx/drawing/layout.py b/networkx/drawing/layout.py\nindex 269246d..98f6448 100644\n--- a/networkx/drawing/layout.py\n+++ b/networkx/drawing/layout.py\n@@ -243,7 +243,7 @@ def shell_layout(G, nlist=None, scale=1, center=None, dim=2):\n         if len(pos) > 1:\n             pos = rescale_layout(pos, scale=scale * radius / len(nlist)) + center\n         else:\n-            pos = np.array([(scale * radius + center[0], center[1])])\n+            pos = np.array([(center[0], center[1])])\n         npos.update(zip(nodes, pos))\n         radius += 1.0\n \n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-2785", "model_patch": "diff --git a/altair/vegalite/v5/theme.py b/altair/vegalite/v5/theme.py\nindex 12f32cd..1fff7b2 100644\n--- a/altair/vegalite/v5/theme.py\n+++ b/altair/vegalite/v5/theme.py\n@@ -22,7 +22,7 @@ class VegaTheme(object):\n     def __call__(self):\n         return {\n             \"usermeta\": {\"embedOptions\": {\"theme\": self.theme}},\n-            \"config\": {\"view\": {\"continuousWidth\": 400, \"continuousHeight\": 300}},\n+            \"config\": {\"view\": {\"continuousWidth\": 300, \"continuousHeight\": 300}},\n         }\n \n     def __repr__(self):\n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-1092", "model_patch": "diff --git a/altair/utils/data.py b/altair/utils/data.py\nindex 64634d6..6a7171a 100644\n--- a/altair/utils/data.py\n+++ b/altair/utils/data.py\n@@ -26,6 +26,21 @@ class DataTransformerRegistry(PluginRegistry[DataTransformerType]):\n     def consolidate_datasets(self, value):\n         self._global_settings['consolidate_datasets'] = value\n \n+    def transform_data(self, data: Dict) -> Dict:\n+        if self.consolidate_datasets:\n+            # Ensure the format property is preserved during consolidation\n+            format_property = data.get('format', None)\n+            transformed_data = self._consolidate_datasets(data['values'])\n+            if format_property:\n+                transformed_data['format'] = format_property\n+            return transformed_data\n+        else:\n+            return data\n+\n+    def _consolidate_datasets(self, values: List) -> Dict:\n+        # Example consolidation logic (this is just a placeholder)\n+        return {'values': values}\n+\n \n # ==============================================================================\n # Data model transformers\n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-974", "model_patch": "diff --git a/altair/utils/data.py b/altair/utils/data.py\nindex 26f1390..23b6feb 100644\n--- a/altair/utils/data.py\n+++ b/altair/utils/data.py\n@@ -145,6 +145,9 @@ def _data_to_json_string(data):\n     check_data_type(data)\n     if isinstance(data, pd.DataFrame):\n         data = sanitize_dataframe(data)\n+        # Convert Timedelta objects to strings\n+        for col in data.select_dtypes(include=[pd.Timedelta]).columns:\n+            data[col] = data[col].astype(str)\n         return data.to_json(orient='records')\n     elif isinstance(data, dict):\n         if 'values' not in data:\n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-830", "model_patch": "diff --git a/altair/vegalite/v2/api.py b/altair/vegalite/v2/api.py\nindex f380dc9..698424e 100644\n--- a/altair/vegalite/v2/api.py\n+++ b/altair/vegalite/v2/api.py\n@@ -897,14 +897,18 @@ class EncodingMixin(object):\n                 return obj\n \n         for prop, obj in list(kwargs.items()):\n-            try:\n-                condition = obj['condition']\n-            except (KeyError, TypeError):\n-                pass\n+            if prop == 'tooltip' and isinstance(obj, list):\n+                # Wrap each item in the list with the appropriate channel class\n+                kwargs[prop] = [_wrap_in_channel_class(item, prop) for item in obj]\n             else:\n-                if condition is not Undefined:\n-                    obj['condition'] = _wrap_in_channel_class(condition, prop)\n-            kwargs[prop] = _wrap_in_channel_class(obj, prop)\n+                try:\n+                    condition = obj['condition']\n+                except (KeyError, TypeError):\n+                    pass\n+                else:\n+                    if condition is not Undefined:\n+                        obj['condition'] = _wrap_in_channel_class(condition, prop)\n+                kwargs[prop] = _wrap_in_channel_class(obj, prop)\n \n \n         copy = self.copy(deep=True, ignore=['data'])\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-27754", "model_patch": "diff --git a/lib/matplotlib/quiver.py b/lib/matplotlib/quiver.py\nindex 6752bb3..bca7e3b 100644\n--- a/lib/matplotlib/quiver.py\n+++ b/lib/matplotlib/quiver.py\n@@ -537,6 +537,10 @@ class Quiver(mcollections.PolyCollection):\n         self._init()\n         verts = self._make_verts(self.XY, self.U, self.V, self.angles)\n         self.set_verts(verts, closed=False)\n+        if self.get_array() is not None:\n+            # Ensure that the facecolors and edgecolors are set correctly\n+            self.set_facecolor(self.get_array())\n+            self.set_edgecolor(self.get_array())\n         super().draw(renderer)\n         self.stale = False\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26926", "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex c89d3d2..ef5833c 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -346,7 +346,7 @@ class Legend(Artist):\n \n     # 'best' is only implemented for axes legends\n     codes = {'best': 0, **AnchoredOffsetbox.codes}\n-    zorder = 5\n+    zorder = 10\n \n     def __str__(self):\n         return \"Legend\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26788", "model_patch": "diff --git a/lib/matplotlib/projections/polar.py b/lib/matplotlib/projections/polar.py\nindex 5061f30..53b3aed 100644\n--- a/lib/matplotlib/projections/polar.py\n+++ b/lib/matplotlib/projections/polar.py\n@@ -1451,6 +1451,18 @@ class PolarAxes(Axes):\n         \"\"\"\n         return 1.0\n \n+    def axhline(self, y=0, xmin=0, xmax=1, **kwargs):\n+        \"\"\"\n+        Draw a horizontal line at *y* from *xmin* to *xmax*\n+        in polar coordinates, this would mean drawing a circle at radius *y*.\n+        \"\"\"\n+        if 'transform' not in kwargs:\n+            kwargs['transform'] = self.transData\n+        line = super().axhline(y, xmin, xmax, **kwargs)\n+        if hasattr(line, 'get_path'):\n+            line.get_path()._interpolation_steps = 180\n+        return line\n+\n     # # # Interactive panning\n \n     def can_zoom(self):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26586", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-26941", "model_patch": "diff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex c3ec08b..5602a97 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -1044,6 +1044,9 @@ class Basic(Printable):\n             elif isinstance(sequence, (Dict, Mapping)):\n                 unordered = True\n                 sequence = sequence.items()\n+            elif isinstance(sequence, TaylorSeries):\n+                unordered = True\n+                sequence = [(x, sequence.removeO())]\n             elif not iterable(sequence):\n                 raise ValueError(filldedent(\"\"\"\n                    When a single argument is passed to subs\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3458", "model_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 685ce8a..7d275dc 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1550,10 +1550,14 @@ class Plotter:\n                     out_df = data.frame.copy()\n \n             scales = self._scales.copy()\n-            if x in out_df:\n-                scales[\"x\"] = self._scales[x]\n-            if y in out_df:\n-                scales[\"y\"] = self._scales[y]\n+            for axis, var in zip(\"xy\", (x, y)):\n+                if var in out_df:\n+                    scales[axis] = self._scales.get(var, self._scales.get(axis, {}))\n+            # Ensure that scales are applied to all subplots in the pair plot\n+            for subplot in subplots:\n+                subplot_scales = subplot.get(\"scales\", {}).copy()\n+                subplot_scales.update(scales)\n+                subplot[\"scales\"] = subplot_scales\n \n             for axis, var in zip(\"xy\", (x, y)):\n                 if axis != var:\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3454", "model_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex f389f7c..5d1d3f9 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1709,15 +1709,10 @@ class Plotter:\n             # but will need the name in the next step to title the legend\n             if key in merged_contents:\n                 # Copy so inplace updates don't propagate back to legend_contents\n-                existing_artists = merged_contents[key][0]\n-                for i, artist in enumerate(existing_artists):\n-                    # Matplotlib accepts a tuple of artists and will overlay them\n-                    if isinstance(artist, tuple):\n-                        artist += new_artists[i],\n-                    else:\n-                        existing_artists[i] = artist, new_artists[i]\n+                existing_artists, existing_labels = merged_contents[key]\n+                merged_contents[key] = (existing_artists + new_artists, existing_labels + labels)\n             else:\n-                merged_contents[key] = new_artists.copy(), labels\n+                merged_contents[key] = (new_artists.copy(), labels.copy())\n \n         # TODO explain\n         loc = \"center right\" if self._pyplot else \"center left\"\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10097", "model_patch": "diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py\nindex 000b451..0a1b84d 100644\n--- a/sphinx/builders/latex/transforms.py\n+++ b/sphinx/builders/latex/transforms.py\n@@ -606,6 +606,11 @@ class IndexInSectionTitleTransform(SphinxPostTransform):\n             if isinstance(node.parent, nodes.section):\n                 for i, index in enumerate(node.findall(addnodes.index)):\n                     # move the index node next to the section title\n+                    # Truncate the index entry to prevent overflow in LaTeX\n+                    MAX_INDEX_LENGTH = 100\n+                    for entry in index['entries']:\n+                        if len(entry[1]) > MAX_INDEX_LENGTH:\n+                            entry[1] = entry[1][:MAX_INDEX_LENGTH] + '...'\n                     node.remove(index)\n                     node.parent.insert(i + 1, index)\n \n"}
