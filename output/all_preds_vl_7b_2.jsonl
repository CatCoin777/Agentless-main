{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-11693", "model_patch": "diff --git a/astropy/wcs/wcsapi/fitswcs.py b/astropy/wcs/wcsapi/fitswcs.py\nindex ce29e86..e2df1a5 100644\n--- a/astropy/wcs/wcsapi/fitswcs.py\n+++ b/astropy/wcs/wcsapi/fitswcs.py\n@@ -323,7 +323,7 @@ class FITSWCSAPIMixin(BaseLowLevelWCS, HighLevelWCSMixin):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n \n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        pixel = self.all_world2pix(*world_arrays, 0, quiet=True)\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n \n     @property\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14295", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex cf86591..25de996 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -707,49 +707,10 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n     def _fix_scamp(self):\n         \"\"\"\n-        Remove SCAMP's PVi_m distortion parameters if SIP distortion parameters\n-        are also present. Some projects (e.g., Palomar Transient Factory)\n-        convert SCAMP's distortion parameters (which abuse the PVi_m cards) to\n-        SIP. However, wcslib gets confused by the presence of both SCAMP and\n-        SIP distortion parameters.\n-\n-        See https://github.com/astropy/astropy/issues/299.\n+        Placeholder method for fixing SCAMP-related issues. This is currently a no-op\n+        to avoid removing PV keywords when SIP is present.\n         \"\"\"\n-        # Nothing to be done if no WCS attached\n-        if self.wcs is None:\n-            return\n-\n-        # Nothing to be done if no PV parameters attached\n-        pv = self.wcs.get_pv()\n-        if not pv:\n-            return\n-\n-        # Nothing to be done if axes don't use SIP distortion parameters\n-        if self.sip is None:\n-            return\n-\n-        # Nothing to be done if any radial terms are present...\n-        # Loop over list to find any radial terms.\n-        # Certain values of the `j' index are used for storing\n-        # radial terms; refer to Equation (1) in\n-        # <http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf>.\n-        pv = np.asarray(pv)\n-        # Loop over distinct values of `i' index\n-        for i in set(pv[:, 0]):\n-            # Get all values of `j' index for this value of `i' index\n-            js = set(pv[:, 1][pv[:, 0] == i])\n-            # Find max value of `j' index\n-            max_j = max(js)\n-            for j in (3, 11, 23, 39):\n-                if j < max_j and j in js:\n-                    return\n-\n-        self.wcs.set_pv([])\n-        warnings.warn(\n-            \"Removed redundant SCAMP distortion parameters \"\n-            + \"because SIP parameters are also present\",\n-            FITSFixedWarning,\n-        )\n+        pass\n \n     def fix(self, translate_units=\"\", naxis=None):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-8292", "model_patch": "diff --git a/astropy/units/equivalencies.py b/astropy/units/equivalencies.py\nindex ac09b48..88250a2 100644\n--- a/astropy/units/equivalencies.py\n+++ b/astropy/units/equivalencies.py\n@@ -728,6 +728,7 @@ def with_H0(H0=None):\n         from astropy import cosmology\n         H0 = cosmology.default_cosmology.get().H0\n \n-    h100_val_unit = Unit(H0.to((si.km/si.s)/astrophys.Mpc).value/100 * astrophys.littleh)\n+    h_val = H0.to((si.km/si.s)/astrophys.Mpc).value / 100\n+    return [(astrophys.Mpc / astrophys.littleh, astrophys.Mpc, lambda x: x * h_val, lambda x: x / h_val)]\n \n-    return [(h100_val_unit, None)]\n+    return [(h100_val_unit, None)]\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13908", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 9ab7174..e3fb6d1 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1324,7 +1324,7 @@ class Axis(martist.Artist):\n         tol = (hi - lo) * 1e-5\n         minor_locs = [\n             loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n-            if not np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n+            if not np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).all()]\n         return minor_locs\n \n     def get_ticklocs(self, minor=False):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13980", "model_patch": "diff --git a/lib/matplotlib/projections/polar.py b/lib/matplotlib/projections/polar.py\nindex ffdbea1..4601527 100644\n--- a/lib/matplotlib/projections/polar.py\n+++ b/lib/matplotlib/projections/polar.py\n@@ -812,6 +812,7 @@ class PolarAxes(Axes):\n         self.set_rorigin(None)\n         self.set_theta_offset(self._default_theta_offset)\n         self.set_theta_direction(self._default_theta_direction)\n+        self.set_rlim(bottom=0)  # Ensure radial limit starts from zero\n \n     def _init_axis(self):\n         \"move this out of __init__ because non-separable axes don't use it\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13983", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 1ebbf68..c5c36e1 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1592,10 +1592,23 @@ default: 'top'\n \n     def _remove_ax(self, ax):\n         def _reset_loc_form(axis):\n-            axis.set_major_formatter(axis.get_major_formatter())\n-            axis.set_major_locator(axis.get_major_locator())\n-            axis.set_minor_formatter(axis.get_minor_formatter())\n-            axis.set_minor_locator(axis.get_minor_locator())\n+            if axis.xaxis.isDefault_majloc:\n+                axis.xaxis.set_major_locator(axis.xaxis.get_major_locator())\n+            if axis.xaxis.isDefault_minloc:\n+                axis.xaxis.set_minor_locator(axis.xaxis.get_minor_locator())\n+            if axis.xaxis.isDefault_majfmt:\n+                axis.xaxis.set_major_formatter(axis.xaxis.get_major_formatter())\n+            if axis.xaxis.isDefault_minfmt:\n+                axis.xaxis.set_minor_formatter(axis.xaxis.get_minor_formatter())\n+\n+            if axis.yaxis.isDefault_majloc:\n+                axis.yaxis.set_major_locator(axis.yaxis.get_major_locator())\n+            if axis.yaxis.isDefault_minloc:\n+                axis.yaxis.set_minor_locator(axis.yaxis.get_minor_locator())\n+            if axis.yaxis.isDefault_majfmt:\n+                axis.yaxis.set_major_formatter(axis.yaxis.get_major_formatter())\n+            if axis.yaxis.isDefault_minfmt:\n+                axis.yaxis.set_minor_formatter(axis.yaxis.get_minor_formatter())\n \n         def _break_share_link(ax, grouper):\n             siblings = grouper.get_siblings(ax)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-13984", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 4fde2d7..2b25831 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -933,6 +933,9 @@ class Axis(martist.Artist):\n             c = kw.pop('colors')\n             kwtrans['color'] = c\n             kwtrans['labelcolor'] = c\n+            # Also set the color for the tick lines\n+            kwtrans['tick1line.color'] = c\n+            kwtrans['tick2line.color'] = c\n         # Maybe move the checking up to the caller of this method.\n         for key in kw:\n             if key not in kwkeys:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-14043", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 907078b..b2e55f3 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2423,6 +2423,7 @@ class Axes(_AxesBase):\n                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]\n \n             error_kw.setdefault(\"label\", '_nolegend_')\n+            error_kw.setdefault(\"zorder\", level)  # Add this line to set zorder for error bars\n \n             errorbar = self.errorbar(ex, ey,\n                                      yerr=yerr, xerr=xerr,\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-14623", "model_patch": "diff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex bf0245b..59b833f 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -425,6 +425,10 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n+        # Ensure vmin is the smaller value and vmax is the larger value for log scale\n+        if vmin > vmax:\n+            vmin, vmax = vmax, vmin\n+\n         return (minpos if vmin <= 0 else vmin,\n                 minpos if vmax <= 0 else vmax)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20470", "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex 62448a6..7644f3c 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -649,7 +649,8 @@ class Legend(Artist):\n             update_func=legend_handler.update_from_first_child),\n         tuple: legend_handler.HandlerTuple(),\n         PathCollection: legend_handler.HandlerPathCollection(),\n-        PolyCollection: legend_handler.HandlerPolyCollection()\n+        PolyCollection: legend_handler.HandlerPolyCollection(),\n+        Text: legend_handler.HandlerText()  # This line adds a handler for Text objects\n         }\n \n     # (get|set|update)_default_handler_maps are public interfaces to\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20518", "model_patch": "diff --git a/lib/matplotlib/backends/backend_pgf.py b/lib/matplotlib/backends/backend_pgf.py\nindex 4adb106..60ba543 100644\n--- a/lib/matplotlib/backends/backend_pgf.py\n+++ b/lib/matplotlib/backends/backend_pgf.py\n@@ -436,13 +436,24 @@ class RendererPgf(RendererBase):\n \n     def draw_path(self, gc, path, transform, rgbFace=None):\n         # docstring inherited\n+        from matplotlib.backends.backend_bases import PathEffectRenderer\n+        from .patheffects import SketchPath\n         writeln(self.fh, r\"\\begin{pgfscope}\")\n         # draw the path\n         self._print_pgf_clip(gc)\n         self._print_pgf_path_styles(gc, rgbFace)\n-        self._print_pgf_path(gc, path, transform, rgbFace)\n-        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n-                            fill=rgbFace is not None)\n+\n+        # Check if sketch_params are set and apply them\n+        sketch_params = gc.get_sketch_params()\n+        if sketch_params:\n+            sketch_path_effect = SketchPath(*sketch_params)\n+            renderer = PathEffectRenderer([sketch_path_effect], self.fh)\n+            renderer.draw_path(gc, path, transform, rgbFace)\n+        else:\n+            self._print_pgf_path(gc, path, transform, rgbFace)\n+            self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n+                                fill=rgbFace is not None)\n+\n         writeln(self.fh, r\"\\end{pgfscope}\")\n \n         # if present, draw pattern on top\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..b72e8bc 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1458,14 +1458,7 @@ class LineCollection(Collection):\n             List of segments in the LineCollection. Each list item contains an\n             array of vertices.\n         \"\"\"\n-        segments = []\n-\n-        for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n-            segments.append(vertices)\n-\n-        return segments\n+        return [path.vertices for path in self._paths]\n \n     def _add_offsets(self, segs):\n         offsets = self._uniform_offsets\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20761", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 7d40e57..4cfe4ce 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -297,9 +297,10 @@ def _make_margin_suptitles(fig, renderer, *, w_pad=0, h_pad=0):\n     if fig._supxlabel is not None and fig._supxlabel.get_in_layout():\n         p = fig._supxlabel.get_position()\n         if getattr(fig._supxlabel, '_autopos', False):\n+            # Only adjust the y position, not the x position\n             fig._supxlabel.set_position((p[0], h_pad_local))\n-            bbox = inv_trans_fig(fig._supxlabel.get_tightbbox(renderer))\n-            fig._layoutgrid.edit_margin_min('bottom', bbox.height + 2 * h_pad)\n+        bbox = inv_trans_fig(fig._supxlabel.get_tightbbox(renderer))\n+        fig._layoutgrid.edit_margin_min('bottom', bbox.height + 2 * h_pad)\n \n     if fig._supylabel is not None and fig._supxlabel.get_in_layout():\n         p = fig._supylabel.get_position()\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20826", "model_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 07605b5..a1781ab 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1203,6 +1203,7 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            self.xaxis.set_visible(self._sharex.xaxis.get_visible())\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1212,7 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            self.yaxis.set_visible(self._sharey.yaxis.get_visible())\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21443", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 94094ef..9e4cd2f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -1062,6 +1062,9 @@ def axes(arg=None, **kwargs):\n     if arg is None:\n         return fig.add_subplot(**kwargs)\n     else:\n+        # Ensure unique label for each axes to avoid reusing existing axes\n+        if 'label' not in kwargs:\n+            kwargs['label'] = f\"axes_{len(fig.axes)}\"\n         return fig.add_axes(arg, **kwargs)\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21490", "model_patch": "diff --git a/lib/matplotlib/lines.py b/lib/matplotlib/lines.py\nindex 06a24c6..5a548f2 100644\n--- a/lib/matplotlib/lines.py\n+++ b/lib/matplotlib/lines.py\n@@ -1230,7 +1230,7 @@ class Line2D(Artist):\n         ----------\n         x : 1D array\n         \"\"\"\n-        self._xorig = x\n+        self._xorig = np.array(x, copy=True)\n         self._invalidx = True\n         self.stale = True\n \n@@ -1242,7 +1242,7 @@ class Line2D(Artist):\n         ----------\n         y : 1D array\n         \"\"\"\n-        self._yorig = y\n+        self._yorig = np.array(y, copy=True)\n         self._invalidy = True\n         self.stale = True\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21550", "model_patch": "diff --git a/lib/matplotlib/backends/backend_nbagg.py b/lib/matplotlib/backends/backend_nbagg.py\nindex ca8cc6a..e44a533 100644\n--- a/lib/matplotlib/backends/backend_nbagg.py\n+++ b/lib/matplotlib/backends/backend_nbagg.py\n@@ -88,9 +88,10 @@ class FigureManagerNbAgg(FigureManagerWebAgg):\n         if not self._shown:\n             self.display_js()\n             self._create_comm()\n+            self._shown = True\n         else:\n             self.canvas.draw_idle()\n-        self._shown = True\n+            self._shown = True\n \n     def reshow(self):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21568", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex f565bc8..9f8568d 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -592,12 +592,9 @@ def drange(dstart, dend, delta):\n \n \n def _wrap_in_tex(text):\n-    p = r'([a-zA-Z]+)'\n-    ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n-\n-    # Braces ensure dashes are not spaced like binary operators.\n-    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n-    ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    # Ensure that the text is wrapped in TeX math mode without disrupting spacing\n+    ret_text = text.replace('-', r'{-}')\n+    ret_text = r'$\\mathdefault{' + ret_text + r'}$'\n     return ret_text\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-21617", "model_patch": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex fb47884..088c28a 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -678,7 +678,6 @@ grestore\n                             for x, name in xs_names)\n         self._pswriter.write(f\"\"\"\\\n gsave\n-{self._get_clip_cmd(gc)}\n {x:f} {y:f} translate\n {angle:f} rotate\n {thetext}\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22865", "model_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex 5ebeaf9..29f3eb4 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -625,9 +625,9 @@ class Colorbar:\n \n         if self._filled:\n             ind = np.arange(len(self._values))\n-            if self._extend_lower():\n+            if self._extend_lower() and not self.drawedges:\n                 ind = ind[1:]\n-            if self._extend_upper():\n+            if self._extend_upper() and not self.drawedges:\n                 ind = ind[:-1]\n             self._add_solids(X, Y, self._values[ind, np.newaxis])\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22871", "model_patch": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex cc65fc1..90f292f 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -797,14 +797,16 @@ class ConciseDateFormatter(ticker.Formatter):\n         # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n         for level in range(5, -1, -1):\n             if len(np.unique(tickdate[:, level])) > 1:\n-                if level < 2:\n-                    show_offset = False\n                 break\n             elif level == 0:\n                 # all tickdate are the same, so only micros might be different\n                 # set to the most precise (6: microseconds doesn't exist...)\n                 level = 5\n \n+        # Ensure the offset is shown if the range is less than a year\n+        if level < 2:\n+            show_offset = True\n+\n         # level is the basic level we will label at.\n         # now loop through and decide the actual ticklabels\n         zerovals = [0, 1, 1, 0, 0, 0, 0]\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-22931", "model_patch": "diff --git a/lib/matplotlib/lines.py b/lib/matplotlib/lines.py\nindex aeed546..cc560a9 100644\n--- a/lib/matplotlib/lines.py\n+++ b/lib/matplotlib/lines.py\n@@ -1247,9 +1247,9 @@ class Line2D(Artist):\n         ----------\n         seq : sequence of floats (on/off ink in points) or (None, None)\n             If *seq* is empty or ``(None, None)``, the linestyle will be set\n-            to solid.\n+            to solid. Also handle `()` as a solid line.\n         \"\"\"\n-        if seq == (None, None) or len(seq) == 0:\n+        if seq == (None, None) or len(seq) == 0 or seq == ():\n             self.set_linestyle('-')\n         else:\n             self.set_linestyle((0, seq))\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23047", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex b6e8396..72d09b3 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6634,9 +6634,9 @@ such objects\n             else:\n                 _w = None\n             bins = np.histogram_bin_edges(\n-                np.concatenate(x), bins, bin_range, _w)\n+                np.concatenate(x).astype(np.float32), bins, (bin_range[0].astype(np.float32), bin_range[1].astype(np.float32)), _w)\n         else:\n-            hist_kwargs['range'] = bin_range\n+            hist_kwargs['range'] = (bin_range[0].astype(np.float32), bin_range[1].astype(np.float32))\n \n         density = bool(density)\n         if density and not stacked:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23111", "model_patch": "diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 80b1e1a..51157fb 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -2157,8 +2157,8 @@ def _g_sig_digits(value, delta):\n     \"\"\"\n     if delta == 0:\n         # delta = 0 may occur when trying to format values over a tiny range;\n-        # in that case, replace it by the distance to the closest float.\n-        delta = np.spacing(value)\n+        # in that case, replace it by the distance to the closest float or a small epsilon value.\n+        delta = max(np.spacing(value), 1e-10)\n     # If e.g. value = 45.67 and delta = 0.02, then we want to round to 2 digits\n     # after the decimal point (floor(log10(0.02)) = -2); 45.67 contributes 2\n     # digits before the decimal point (floor(log10(45.67)) + 1 = 2): the total\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24177", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 36d6e8e..0adf1c1 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6876,19 +6876,23 @@ such objects\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n-                patches.append(self.fill(\n+                patch = self.fill(\n                     x[:split], y[:split],\n                     closed=True if fill else None,\n                     facecolor=c,\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n-                    zorder=None if fill else mlines.Line2D.zorder))\n-            for patch_list in patches:\n-                for patch in patch_list:\n-                    if orientation == 'vertical':\n-                        patch.sticky_edges.y.append(0)\n-                    elif orientation == 'horizontal':\n-                        patch.sticky_edges.x.append(0)\n+                    zorder=None if fill else mlines.Line2D.zorder)\n+                patches.append(patch)\n+\n+                # Set sticky edges for the step plot\n+                if fill:\n+                    patch.sticky_edges.y.append(0)\n+                else:\n+                    patch.sticky_edges.y.append(y[-2])\n+\n+                if orientation == 'horizontal':\n+                    patch.sticky_edges.x.append(0)\n \n             # we return patches, so put it back in the expected order\n             patches.reverse()\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..cab0a52 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2021,8 +2021,11 @@ default: %(va)s\n                     j, k = key\n                     # recursively add the nested mosaic\n                     rows, cols = nested_mosaic.shape\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24691", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 3884459..29e2b56 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -73,6 +73,9 @@ class Patch(artist.Artist):\n \n         self._hatch_color = colors.to_rgba(mpl.rcParams['hatch.color'])\n         self._fill = True  # needed for set_facecolor call\n+        self._face_alpha = None\n+        self._edge_alpha = None\n+\n         if color is not None:\n             if edgecolor is not None or facecolor is not None:\n                 _api.warn_external(\n@@ -83,6 +86,17 @@ class Patch(artist.Artist):\n             self.set_edgecolor(edgecolor)\n             self.set_facecolor(facecolor)\n \n+        if alpha is not None:\n+            if isinstance(alpha, (tuple, dict)):\n+                if isinstance(alpha, tuple) and len(alpha) == 2:\n+                    self._face_alpha, self._edge_alpha = alpha\n+                elif isinstance(alpha, dict):\n+                    self._face_alpha = alpha.get('face', self._alpha)\n+                    self._edge_alpha = alpha.get('edge', self._alpha)\n+            else:\n+                self._face_alpha = alpha\n+                self._edge_alpha = alpha\n+\n         self._linewidth = 0\n         self._unscaled_dash_pattern = (0, None)  # offset, dash\n         self._dash_pattern = (0, None)  # offset, dash (scaled by linewidth)\n@@ -97,6 +111,8 @@ class Patch(artist.Artist):\n \n         if len(kwargs):\n             self._internal_update(kwargs)\n+        self._set_facecolor(self._original_facecolor)\n+        self._set_edgecolor(self._original_edgecolor)\n \n     def get_verts(self):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24749", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex ff145f1..e1c6e82 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2497,6 +2497,8 @@ def cohere(\n # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n @_copy_docstring_and_deprecators(Axes.contour)\n def contour(*args, data=None, **kwargs):\n+    if 'Z' in kwargs:\n+        args = (kwargs.pop('Z'),) + args\n     __ret = gca().contour(\n         *args, **({\"data\": data} if data is not None else {}),\n         **kwargs)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24768", "model_patch": "diff --git a/lib/matplotlib/backends/backend_mixed.py b/lib/matplotlib/backends/backend_mixed.py\nindex d4ce0aa..e63bc80 100644\n--- a/lib/matplotlib/backends/backend_mixed.py\n+++ b/lib/matplotlib/backends/backend_mixed.py\n@@ -93,21 +93,22 @@ class MixedModeRenderer:\n \n         self._renderer = self._vector_renderer\n \n-        height = self._height * self.dpi\n-        img = np.asarray(self._raster_renderer.buffer_rgba())\n-        slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n-        cropped_img = img[slice_y, slice_x]\n-        if cropped_img.size:\n-            gc = self._renderer.new_gc()\n-            # TODO: If the mixedmode resolution differs from the figure's\n-            #       dpi, the image must be scaled (dpi->_figdpi). Not all\n-            #       backends support this.\n-            self._renderer.draw_image(\n-                gc,\n-                slice_x.start * self._figdpi / self.dpi,\n-                (height - slice_y.stop) * self._figdpi / self.dpi,\n-                cropped_img[::-1])\n-        self._raster_renderer = None\n+        if self._raster_renderer is not None:\n+            height = self._height * self.dpi\n+            img = np.asarray(self._raster_renderer.buffer_rgba())\n+            slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n+            cropped_img = img[slice_y, slice_x]\n+            if cropped_img.size:\n+                gc = self._renderer.new_gc()\n+                # TODO: If the mixedmode resolution differs from the figure's\n+                #       dpi, the image must be scaled (dpi->_figdpi). Not all\n+                #       backends support this.\n+                self._renderer.draw_image(\n+                    gc,\n+                    slice_x.start * self._figdpi / self.dpi,\n+                    (height - slice_y.stop) * self._figdpi / self.dpi,\n+                    cropped_img[::-1])\n+            self._raster_renderer = None\n \n         # restore the figure dpi.\n         self.figure.dpi = self._figdpi\n@@ -116,4 +117,4 @@ class MixedModeRenderer:\n             r = process_figure_for_rasterizing(self.figure,\n                                                self._bbox_inches_restore,\n                                                self._figdpi)\n-            self._bbox_inches_restore = r\n+            self._bbox_inches_restore = r\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24849", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex dfe01a6..f96ab50 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1479,6 +1479,13 @@ class LineCollection(Collection):\n \n     get_colors = get_color  # for compatibility with old versions\n \n+    def get_gapcolor(self):\n+        return self._gapcolor\n+\n+    def set_gapcolor(self, gapcolor):\n+        self._gapcolor = gapcolor\n+        self.stale = True\n+\n \n class EventCollection(LineCollection):\n     \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24870", "model_patch": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 908a24f..ed9c40f 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1123,7 +1123,10 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n         \"\"\"\n         if self.levels is None:\n             if len(args) == 0:\n-                levels_arg = 7  # Default, hard-wired.\n+                if isinstance(self._A, np.ndarray) and self._A.dtype == bool:\n+                    levels_arg = [0.5]\n+                else:\n+                    levels_arg = 7  # Default, hard-wired.\n             else:\n                 levels_arg = args[0]\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24971", "model_patch": "diff --git a/lib/matplotlib/_tight_bbox.py b/lib/matplotlib/_tight_bbox.py\nindex b0a0529..ea6e867 100644\n--- a/lib/matplotlib/_tight_bbox.py\n+++ b/lib/matplotlib/_tight_bbox.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Helper module for the *bbox_inches* parameter in `.Figure.savefig`.\n \"\"\"\n@@ -18,8 +19,12 @@ def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n     origBbox = fig.bbox\n     origBboxInches = fig.bbox_inches\n     orig_layout = fig.get_layout_engine()\n+    orig_compress = fig.get_constrained_layout_pads().get('compress', False)\n     fig.set_layout_engine(None)\n     _boxout = fig.transFigure._boxout\n+    # Save the compress setting\n+    fig.set_constrained_layout_pads(compress=orig_compress)\n+    # Restore the compress setting in the restore function\n \n     old_aspect = []\n     locator_list = []\n@@ -47,6 +52,8 @@ def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n         fig.bbox = origBbox\n         fig.bbox_inches = origBboxInches\n         fig.set_layout_engine(orig_layout)\n+        if orig_layout is not None and hasattr(orig_layout, 'compress'):\n+            fig.get_layout_engine().compress = orig_compress\n         fig.transFigure._boxout = _boxout\n         fig.transFigure.invalidate()\n         fig.patch.set_bounds(0, 0, 1, 1)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25287", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex 40bf7c6..0920063 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -2255,7 +2255,7 @@ class XAxis(Axis):\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['xtick.labelsize'],\n-            color=mpl.rcParams['xtick.color'],\n+            color=mpl.rcParams['xtick.color'] if mpl.rcParams['xtick.labelcolor']=='inherit' else mpl.rcParams['xtick.labelcolor'],\n         )\n         self.offset_text_position = 'bottom'\n \n@@ -2515,7 +2515,7 @@ class YAxis(Axis):\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['ytick.labelsize'],\n-            color=mpl.rcParams['ytick.color'],\n+            color=mpl.rcParams['ytick.color'] if mpl.rcParams['ytick.labelcolor']=='inherit' else mpl.rcParams['ytick.labelcolor'],\n         )\n         self.offset_text_position = 'left'\n \n@@ -2739,4 +2739,4 @@ class YAxis(Axis):\n         if size > 0:\n             return int(np.floor(length / size))\n         else:\n-            return 2**31 - 1\n+            return 2**31 - 1\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex 92db988..51be1de 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -638,16 +638,25 @@ class Text(Artist):\n         self.set_rotation_mode('anchor')\n         rotation = self.get_rotation()\n \n-        left = self._get_dist_to_box(rotation, x0, y0, figure_box)\n-        right = self._get_dist_to_box(\n-            (180 + rotation) % 360, x0, y0, figure_box)\n+        # Get the bounding box of the axes instead of the figure\n+        ax = self.get_axes()\n+        if ax is None:\n+            left = self._get_dist_to_box(rotation, x0, y0, figure_box)\n+            right = self._get_dist_to_box(\n+                (180 + rotation) % 360, x0, y0, figure_box)\n+        else:\n+            # Calculate the distance from the text position to the bounding box of the axes\n+            axes_box = ax.get_window_extent()\n+            left = self._get_dist_to_box(rotation, x0, y0, axes_box)\n+            right = self._get_dist_to_box(\n+                (180 + rotation) % 360, x0, y0, axes_box)\n \n         if alignment == 'left':\n-            line_width = left\n+            line_width = left - (x0 - axes_box.x0)\n         elif alignment == 'right':\n-            line_width = right\n+            line_width = axes_box.x1 - x0 - right\n         else:\n-            line_width = 2 * min(left, right)\n+            line_width = min(left - (x0 - axes_box.x0), axes_box.x1 - x0 - right)\n \n         return line_width\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25405", "model_patch": "diff --git a/lib/matplotlib/ticker.py b/lib/matplotlib/ticker.py\nindex 3efaa84..20e532d 100644\n--- a/lib/matplotlib/ticker.py\n+++ b/lib/matplotlib/ticker.py\n@@ -2409,14 +2409,14 @@ class LogLocator(Locator):\n                     ticklocs = np.ravel(np.outer(subs, ticklocs))\n                 else:\n                     # No ticklocs if we have >1 decade between major ticks.\n-                    ticklocs = np.array([])\n+                    ticklocs = np.concatenate([subs * decade_start for decade_start in b ** decades])\n         else:\n             if have_subs:\n                 if stride == 1:\n                     ticklocs = np.concatenate(\n                         [subs * decade_start for decade_start in b ** decades])\n                 else:\n-                    ticklocs = np.array([])\n+                    ticklocs = np.concatenate([subs * decade_start for decade_start in b ** decades])\n             else:\n                 ticklocs = b ** decades\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25499", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex e199328..bbb883d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3362,6 +3362,11 @@ None}, default: None\n                 # set axes to be transparent\n                 for ax in self.axes:\n                     _recursively_make_axes_transparent(stack, ax)\n+\n+            # Force layout adjustment before saving the figure\n+            if bbox_inches is not None and bbox_inches != 'tight':\n+                self.tight_layout()\n+\n             self.canvas.print_figure(fname, **kwargs)\n \n     def ginput(self, n=1, timeout=30, show_clicks=True,\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25640", "model_patch": "diff --git a/lib/matplotlib/backends/backend_pgf.py b/lib/matplotlib/backends/backend_pgf.py\nindex 2e88d0c..1335bb7 100644\n--- a/lib/matplotlib/backends/backend_pgf.py\n+++ b/lib/matplotlib/backends/backend_pgf.py\n@@ -670,10 +670,7 @@ class RendererPgf(RendererBase):\n \n         dpi = self.figure.dpi\n         text_args = []\n-        if mtext and (\n-                (angle == 0 or\n-                 mtext.get_rotation_mode() == \"anchor\") and\n-                mtext.get_verticalalignment() != \"center_baseline\"):\n+        if mtext:\n             # if text anchoring can be supported, get the original coordinates\n             # and add alignment information\n             pos = mtext.get_unitless_position()\n@@ -681,12 +678,23 @@ class RendererPgf(RendererBase):\n             halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n             valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                       \"baseline\": \"base\", \"center\": \"\"}\n-            text_args.extend([\n-                f\"x={x/dpi:f}in\",\n-                f\"y={y/dpi:f}in\",\n-                halign[mtext.get_horizontalalignment()],\n-                valign[mtext.get_verticalalignment()],\n-            ])\n+            clip_box = mtext.get_clip_box()\n+            if clip_box:\n+                x0, y0, x1, y1 = clip_box.bounds\n+                text_args.extend([\n+                    f\"x={x/dpi:f}in\",\n+                    f\"y={y/dpi:f}in\",\n+                    halign[mtext.get_horizontalalignment()],\n+                    valign[mtext.get_verticalalignment()],\n+                    f\"clip={x0/dpi:f}in,{y0/dpi:f}in,{x1/dpi:f}in,{y1/dpi:f}in\"\n+                ])\n+            else:\n+                text_args.extend([\n+                    f\"x={x/dpi:f}in\",\n+                    f\"y={y/dpi:f}in\",\n+                    halign[mtext.get_horizontalalignment()],\n+                    valign[mtext.get_verticalalignment()],\n+                ])\n         else:\n             # if not, use the text layout provided by Matplotlib.\n             text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25667", "model_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 6a3d37e..6e63655 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2417,12 +2417,12 @@ class Axes(_AxesBase):\n \n         if orientation == 'vertical':\n             self._process_unit_info(\n-                [(\"x\", x), (\"y\", height)], kwargs, convert=False)\n+                [(\"x\", x), (\"y\", height), (\"bottom\", bottom)], kwargs, convert=False)\n             if log:\n                 self.set_yscale('log', nonpositive='clip')\n         else:  # horizontal\n             self._process_unit_info(\n-                [(\"x\", width), (\"y\", y)], kwargs, convert=False)\n+                [(\"x\", width), (\"y\", y), (\"left\", left)], kwargs, convert=False)\n             if log:\n                 self.set_xscale('log', nonpositive='clip')\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25779", "model_patch": "diff --git a/galleries/examples/text_labels_and_annotations/angle_annotation.py b/galleries/examples/text_labels_and_annotations/angle_annotation.py\nindex c8765a9..c6c43c1 100644\n--- a/galleries/examples/text_labels_and_annotations/angle_annotation.py\n+++ b/galleries/examples/text_labels_and_annotations/angle_annotation.py\n@@ -259,6 +259,65 @@ am5 = AngleAnnotation(p[1], p[0], p[2], ax=ax, size=40, text=r\"$\\Phi$\",\n # The *textposition* and *unit* keyword arguments may be used to modify the\n # location of the text label, as shown below:\n \n+# Helper function to draw angle easily.\n+def plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n+    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n+    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n+    ax.plot(*xy.T, color=acol)\n+    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n+\n+# Function to plot an ellipse with an arrow showing the direction of rotation\n+def plot_ellipse_with_rotation(ax, center, width, height, angle, rotation_direction=\"clockwise\", acol=\"C0\", **kwargs):\n+    \"\"\"\n+    Plots an ellipse with an arrow showing the direction of rotation.\n+\n+    Parameters:\n+    - ax: The Axes object where the ellipse and arrow will be drawn.\n+    - center: A tuple (x, y) representing the center of the ellipse.\n+    - width: The width of the ellipse.\n+    - height: The height of the ellipse.\n+    - angle: The orientation of the ellipse in degrees.\n+    - rotation_direction: A string indicating the direction of rotation, either \"clockwise\" or \"counterclockwise\".\n+    - acol: The color of the arrow.\n+    - kwargs: Additional keyword arguments for the ellipse patch.\n+    \"\"\"\n+    # Create the ellipse\n+    ellipse = Ellipse(center, width, height, angle, **kwargs)\n+    ax.add_patch(ellipse)\n+\n+    # Determine the start and end positions of the arrow\n+    if rotation_direction == \"clockwise\":\n+        start_angle = angle\n+        end_angle = angle - 30\n+    elif rotation_direction == \"counterclockwise\":\n+        start_angle = angle\n+        end_angle = angle + 30\n+    else:\n+        raise ValueError(\"rotation_direction must be 'clockwise' or 'counterclockwise'\")\n+\n+    # Convert angles to radians\n+    start_rad = np.deg2rad(start_angle)\n+    end_rad = np.deg2rad(end_angle)\n+\n+    # Calculate start and end points of the arrow\n+    startpoint = (center[0] + width/2 * np.cos(start_rad), center[1] + width/2 * np.sin(start_rad))\n+    endpoint = (center[0] + width/2 * np.cos(end_rad), center[1] + width/2 * np.sin(end_rad))\n+\n+    # Create the arrow\n+    arrow = FancyArrowPatch(startpoint, endpoint, connectionstyle=\"arc3,rad=.3\", color=acol)\n+    ax.add_patch(arrow)\n+\n+# Example usage\n+fig, ax = plt.subplots()\n+fig.canvas.draw()  # Need to draw the figure to define renderer\n+\n+plot_ellipse_with_rotation(ax, (2, 2), 2, 1, 30, rotation_direction=\"clockwise\", edgecolor=\"blue\", facecolor=\"none\")\n+\n+ax.set_xlim(0, 4)\n+ax.set_ylim(0, 4)\n+ax.set_aspect(\"equal\")\n+plt.show()\n+\n \n # Helper function to draw angle easily.\n def plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26466", "model_patch": "diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex a4bce05..1bc07ba 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -1811,7 +1811,7 @@ or callable, default: value of *xycoords*\n \n         \"\"\"\n         _AnnotationBase.__init__(self,\n-                                 xy,\n+                                 xy.copy(),\n                                  xycoords=xycoords,\n                                  annotation_clip=annotation_clip)\n         # warn about wonky input data\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2576", "model_patch": "diff --git a/seaborn/regression.py b/seaborn/regression.py\nindex 0870277..97caba6 100644\n--- a/seaborn/regression.py\n+++ b/seaborn/regression.py\n@@ -592,7 +592,7 @@ def lmplot(\n         palette=palette,\n         row_order=row_order, col_order=col_order, hue_order=hue_order,\n         height=height, aspect=aspect, col_wrap=col_wrap,\n-        sharex=sharex, sharey=sharey, legend_out=legend_out\n+        sharex=sharex if sharey else False, sharey=sharey, legend_out=legend_out\n     )\n \n     # Add the markers here as FacetGrid has figured out how many levels of the\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2846", "model_patch": "diff --git a/seaborn/_core/data.py b/seaborn/_core/data.py\nindex a66b99b..0690731 100644\n--- a/seaborn/_core/data.py\n+++ b/seaborn/_core/data.py\n@@ -245,18 +245,23 @@ class PlotData:\n                         )\n                         raise ValueError(err)\n \n-                plot_data[key] = val\n+                # Convert numpy arrays to pandas Series if necessary\n+                if isinstance(val, np.ndarray):\n+                    name = str(val.name) if hasattr(val, \"name\") else None\n+                    plot_data[key] = pd.Series(val, name=name)\n+                else:\n+                    plot_data[key] = val\n \n                 # Try to infer the original name using pandas-like metadata\n-                if hasattr(val, \"name\"):\n-                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424\n+                if hasattr(plot_data[key], \"name\"):\n+                    names[key] = ids[key] = str(plot_data[key].name)\n                 else:\n                     names[key] = None\n-                    ids[key] = id(val)\n+                    ids[key] = id(plot_data[key])\n \n         # Construct a tidy plot DataFrame. This will convert a number of\n         # types automatically, aligning on index in case of pandas objects\n         # TODO Note: this fails when variable specs *only* have scalars!\n         frame = pd.DataFrame(plot_data)\n \n-        return frame, names, ids\n+        return frame, names, ids\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-2979", "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 1c8b9dc..aca7b81 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1658,8 +1658,13 @@ class PairGrid(Grid):\n \n     def _add_axis_labels(self):\n         \"\"\"Add labels to the left and bottom Axes.\"\"\"\n+        # Add x-axis labels for the first row\n+        for ax, label in zip(self.axes[0, :], self.x_vars):\n+            ax.set_xlabel(label)\n+        # Add x-axis labels for the last row\n         for ax, label in zip(self.axes[-1, :], self.x_vars):\n             ax.set_xlabel(label)\n+        # Add y-axis labels for the first column\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3180", "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex f23fcd8..331aba1 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -523,7 +523,7 @@ class FacetGrid(Grid):\n         # --- Make the axes look good\n \n         self.set_titles()\n-        self.tight_layout()\n+        self.tight_layout(pad=3)\n \n         if despine:\n             self.despine()\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3187", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 609c102..a9d57ca 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -378,7 +378,13 @@ class ContinuousBase(Scale):\n             axis.set_view_interval(vmin, vmax)\n             locs = axis.major.locator()\n             locs = locs[(vmin <= locs) & (locs <= vmax)]\n-            labels = axis.major.formatter.format_ticks(locs)\n+            formatter = axis.major.formatter\n+            if isinstance(formatter, mpl.ticker.ScalarFormatter) and formatter.useOffset:\n+                offset = formatter.offset\n+                scale_factor = formatter.orderOfMagnitude\n+                labels = [f\"{label}e{scale_factor + offset}\" if label != '' else '' for label in formatter.format_ticks(locs)]\n+            else:\n+                labels = formatter.format_ticks(locs)\n             new._legend = list(locs), list(labels)\n \n         return new\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3202", "model_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 03cb23c..2fde4ad 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -212,6 +212,8 @@ class Nominal(Scale):\n             # TODO isin fails when units_seed mixes numbers and strings (numpy error?)\n             # but np.isin also does not seem any faster? (Maybe not broadcasting in C)\n             # keep = x.isin(units_seed)\n+            if len(x) == 0:\n+                return np.array([], dtype=float)\n             keep = np.array([x_ in units_seed for x_ in x], bool)\n             out = np.full(len(x), np.nan)\n             out[keep] = axis.convert_units(stringify(x[keep]))\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3216", "model_patch": "diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py\nindex d2a47ca..d0bed91 100644\n--- a/seaborn/_core/subplots.py\n+++ b/seaborn/_core/subplots.py\n@@ -183,7 +183,7 @@ class Subplots:\n             hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4\n             and isinstance(target, mpl.figure.SubFigure)\n         ):\n-            figure = target.figure\n+            figure = target\n         elif isinstance(target, mpl.figure.Figure):\n             figure = target\n         else:\n@@ -266,4 +266,4 @@ class Subplots:\n \n     def __len__(self) -> int:\n         \"\"\"Return the number of subplots in this figure.\"\"\"\n-        return len(self._subplot_list)\n+        return len(self._subplot_list)\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3217", "model_patch": "diff --git a/seaborn/distributions.py b/seaborn/distributions.py\nindex 288f4e2..5e3e189 100644\n--- a/seaborn/distributions.py\n+++ b/seaborn/distributions.py\n@@ -489,8 +489,8 @@ class _DistributionPlotter(VectorPlotter):\n \n             # Convert edges back to original units for plotting\n             if self._log_scaled(self.data_variable):\n-                widths = np.power(10, edges + widths) - np.power(10, edges)\n                 edges = np.power(10, edges)\n+                widths = np.diff(edges)  # Compute the difference between transformed edges\n \n             # Pack the histogram data and metadata together\n             edges = edges + (1 - shrink) / 2 * widths\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..e36fa06 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -298,9 +298,8 @@ class _HeatMapper:\n \n         # setting vmin/vmax in addition to norm is deprecated\n         # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n-            kws.setdefault(\"vmin\", self.vmin)\n-            kws.setdefault(\"vmax\", self.vmax)\n+        kws.setdefault(\"vmin\", self.vmin)\n+        kws.setdefault(\"vmax\", self.vmax)\n \n         # Draw the heatmap\n         mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3394", "model_patch": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex 88b4321..bdb2a79 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -392,7 +392,7 @@ class _LinePlotter(_RelationalPlotter):\n             if self.sort:\n                 sort_vars = [\"units\", orient, other]\n                 sort_cols = [var for var in sort_vars if var in self.variables]\n-                sub_data = sub_data.sort_values(sort_cols)\n+                sub_data = sub_data.sort_values(sort_cols, na_position='last')\n \n             if (\n                 self.estimator is not None\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..684afdf 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -184,7 +184,7 @@ def dim_section(obj):\n def array_section(obj):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n-    collapsed = \"\"\n+    collapsed = \"checked\"\n     variable = getattr(obj, \"variable\", obj)\n     preview = escape(inline_variable_array_repr(variable, max_width=70))\n     data_repr = short_data_repr_html(obj)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/plot/utils.py b/xarray/plot/utils.py\nindex 4a784fa..b018ebc 100644\n--- a/xarray/plot/utils.py\n+++ b/xarray/plot/utils.py\n@@ -490,7 +490,11 @@ def label_from_attrs(da, extra=\"\"):\n     else:\n         units = _get_units_from_attrs(da)\n \n-    return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n+    # Check if the name contains LaTeX syntax\n+    if name.startswith(r\"$\") and name.endswith(r\"$\"):\n+        return name + extra + units\n+    else:\n+        return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n \n \n def _interval_to_mid_points(array):\n"}
{"model_name_or_path": "agentless", "instance_id": "pylint-dev__pylint-4551", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13087", "model_patch": "diff --git a/sklearn/calibration.py b/sklearn/calibration.py\nindex 142eda3..e89acd9 100644\n--- a/sklearn/calibration.py\n+++ b/sklearn/calibration.py\n@@ -541,10 +541,11 @@ def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n         a proper probability. If True, the smallest value in y_prob is mapped\n         onto 0 and the largest one onto 1.\n \n-    n_bins : int\n-        Number of bins. A bigger number requires more data. Bins with no data\n-        points (i.e. without corresponding values in y_prob) will not be\n-        returned, thus there may be fewer than n_bins in the return value.\n+    n_bins : int or array-like, optional, default=5\n+        Number of bins or user-defined bin edges. A bigger number requires more\n+        data. Bins with no data points (i.e. without corresponding values in\n+        y_prob) will not be returned, thus there may be fewer bins in the\n+        return value than specified.\n \n     Returns\n     -------\n@@ -572,8 +573,11 @@ def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n \n     y_true = _check_binary_probabilistic_predictions(y_true, y_prob)\n \n-    bins = np.linspace(0., 1. + 1e-8, n_bins + 1)\n-    binids = np.digitize(y_prob, bins) - 1\n+    if isinstance(n_bins, int):\n+        bins = np.linspace(0., 1. + 1e-8, n_bins + 1)\n+    else:\n+        bins = n_bins\n+    binids = np.searchsorted(bins, y_prob, side='right') - 1\n \n     bin_sums = np.bincount(binids, weights=y_prob, minlength=len(bins))\n     bin_true = np.bincount(binids, weights=y_true, minlength=len(bins))\n@@ -583,4 +587,4 @@ def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n     prob_true = (bin_true[nonzero] / bin_total[nonzero])\n     prob_pred = (bin_sums[nonzero] / bin_total[nonzero])\n \n-    return prob_true, prob_pred\n+    return prob_true, prob_pred\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13618", "model_patch": "diff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\nindex 69c9741..082e988 100644\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -157,7 +157,7 @@ class BayesianRidge(LinearModel, RegressorMixin):\n         self.copy_X = copy_X\n         self.verbose = verbose\n \n-    def fit(self, X, y, sample_weight=None):\n+    def fit(self, X, y, sample_weight=None, alpha_0=None, lambda_0=None):\n         \"\"\"Fit the model\n \n         Parameters\n@@ -173,6 +173,12 @@ class BayesianRidge(LinearModel, RegressorMixin):\n             .. versionadded:: 0.20\n                parameter *sample_weight* support to BayesianRidge.\n \n+        alpha_0 : float, optional\n+            Initial value for alpha. If None, it is set to 1. / (np.var(y) + eps).\n+\n+        lambda_0 : float, optional\n+            Initial value for lambda. If None, it is set to 1.\n+\n         Returns\n         -------\n         self : returns an instance of self.\n@@ -199,8 +205,14 @@ class BayesianRidge(LinearModel, RegressorMixin):\n         eps = np.finfo(np.float64).eps\n         # Add `eps` in the denominator to omit division by zero if `np.var(y)`\n         # is zero\n-        alpha_ = 1. / (np.var(y) + eps)\n-        lambda_ = 1.\n+        if alpha_0 is None:\n+            alpha_ = 1. / (np.var(y) + eps)\n+        else:\n+            alpha_ = alpha_0\n+        if lambda_0 is None:\n+            lambda_ = 1.\n+        else:\n+            lambda_ = lambda_0\n \n         verbose = self.verbose\n         lambda_1 = self.lambda_1\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-14067", "model_patch": "diff --git a/sklearn/linear_model/bayes.py b/sklearn/linear_model/bayes.py\nindex d775ddb..9049207 100644\n--- a/sklearn/linear_model/bayes.py\n+++ b/sklearn/linear_model/bayes.py\n@@ -552,10 +552,11 @@ class ARDRegression(LinearModel, RegressorMixin):\n \n         # Compute sigma and mu (using Woodbury matrix identity)\n         def update_sigma(X, alpha_, lambda_, keep_lambda, n_samples):\n-            sigma_ = pinvh(np.eye(n_samples) / alpha_ +\n-                           np.dot(X[:, keep_lambda] *\n-                           np.reshape(1. / lambda_[keep_lambda], [1, -1]),\n-                           X[:, keep_lambda].T))\n+            # Use np.linalg.pinv as an alternative to pinvh for improved numerical stability\n+            sigma_ = np.linalg.pinv(np.eye(n_samples) / alpha_ +\n+                                    np.dot(X[:, keep_lambda] *\n+                                    np.reshape(1. / lambda_[keep_lambda], [1, -1]),\n+                                    X[:, keep_lambda].T))\n             sigma_ = np.dot(sigma_, X[:, keep_lambda] *\n                             np.reshape(1. / lambda_[keep_lambda], [1, -1]))\n             sigma_ = - np.dot(np.reshape(1. / lambda_[keep_lambda], [-1, 1]) *\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10048", "model_patch": "diff --git a/sphinx/writers/html5.py b/sphinx/writers/html5.py\nindex f949c89..5f2a858 100644\n--- a/sphinx/writers/html5.py\n+++ b/sphinx/writers/html5.py\n@@ -320,7 +320,7 @@ class HTML5Translator(SphinxTranslator, BaseTranslator):\n     def add_permalink_ref(self, node: Element, title: str) -> None:\n         if node['ids'] and self.config.html_permalinks and self.builder.add_permalinks:\n             format = '<a class=\"headerlink\" href=\"#%s\" title=\"%s\">%s</a>'\n-            self.body.append(format % (node['ids'][0], title,\n+            self.body.append(format % (node['ids'][0], __('Permalink to this heading'),\n                                        self.config.html_permalinks_icon))\n \n     # overwritten\n@@ -836,4 +836,4 @@ class HTML5Translator(SphinxTranslator, BaseTranslator):\n     def _table_row_index(self):\n         warnings.warn('_table_row_index is deprecated',\n                       RemovedInSphinx60Warning, stacklevel=2)\n-        return self._table_row_indices[-1]\n+        return self._table_row_indices[-1]\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10097", "model_patch": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex b6f63fe..b720f54 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -27,6 +27,14 @@ class IndexEntries:\n     def __init__(self, env: BuildEnvironment) -> None:\n         self.env = env\n \n+    def wrap_long_option_name(self, name: str) -> str:\n+        # Define a maximum length for the option name in the index\n+        max_length = 30\n+        if len(name) > max_length:\n+            # Wrap the name at the specified maximum length\n+            return '\\\\\\\\ '.join([name[i:i+max_length] for i in range(0, len(name), max_length)])\n+        return name\n+\n     def create_index(self, builder: Builder, group_entries: bool = True,\n                      _fixre: Pattern = re.compile(r'(.*) ([(][^()]*[)])')\n                      ) -> List[Tuple[str, List[Tuple[str, Any]]]]:\n@@ -175,4 +183,4 @@ class IndexEntries:\n             else:\n                 return v[2]\n         return [(key_, list(group))\n-                for (key_, group) in groupby(newlist, keyfunc3)]\n+                for (key_, group) in groupby(newlist, keyfunc3)]\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10191", "model_patch": "diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py\nindex 7e5e344..05a03fe 100644\n--- a/sphinx/builders/latex/transforms.py\n+++ b/sphinx/builders/latex/transforms.py\n@@ -440,6 +440,9 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):\n             node.replace_self(mark)\n         else:\n             footnote = self.get_footnote_by_reference(node)\n+            if footnote is None:\n+                raise ValueError(f\"Footnote with reference ID {node['refid']} not found in document {docname}\")\n+\n             if self.restricted:\n                 mark = footnotemark('', number, refid=node['refid'])\n                 node.replace_self(mark)\n@@ -458,7 +461,7 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):\n             if docname == footnote['docname'] and footnote['ids'][0] == node['refid']:\n                 return footnote\n \n-        return None\n+        raise ValueError(f\"Footnote with reference ID {node['refid']} not found in document {docname}\")\n \n \n class BibliographyTransform(SphinxPostTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-10435", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 2dc462a..667ca17 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -721,10 +721,10 @@ class LaTeXTranslator(SphinxTranslator):\n         pass\n \n     def visit_desc_inline(self, node: Element) -> None:\n-        self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n+        self.body.append(r'\\sphinxcode{\\sphinxupquote{%')\n \n     def depart_desc_inline(self, node: Element) -> None:\n-        self.body.append('}}')\n+        self.body.append('}}%')\n \n     # Nodes for high-level structure in signatures\n     ##############################################\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11266", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 4b73f6a..ecf1c50 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -820,7 +820,7 @@ class LaTeXTranslator(SphinxTranslator):\n \n     def visit_seealso(self, node: Element) -> None:\n         self.body.append(BLANKLINE)\n-        self.body.append(r'\\begin{sphinxseealso}{%s}' % admonitionlabels['seealso'] + CR)\n+        self.body.append(r'\\begin{sphinxseealso}{%s }' % admonitionlabels['seealso'] + CR)\n \n     def depart_seealso(self, node: Element) -> None:\n         self.body.append(BLANKLINE)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": ""}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7615", "model_patch": "diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py\nindex 7aaad7b..89c4846 100644\n--- a/sphinx/util/rst.py\n+++ b/sphinx/util/rst.py\n@@ -38,7 +38,8 @@ WIDECHARS[\"ja\"] = \"WFA\"  # In Japanese, Ambiguous characters also have double wi\n \n \n def escape(text: str) -> str:\n-    text = symbols_re.sub(r'\\\\\\1', text)\n+    # Escape all symbols except backslashes\n+    text = symbols_re.sub(lambda m: '\\\\' + m.group(1) if m.group(1) != '\\\\' else m.group(1), text)\n     text = re.sub(r'^\\.', r'\\.', text)  # escape a dot at top\n     return text\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7757", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 3555587..654e5b0 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -178,7 +178,7 @@ def _parse_arglist(arglist: str) -> addnodes.desc_parameterlist:\n                 node += nodes.Text(' ')\n             else:\n                 node += addnodes.desc_sig_operator('', '=')\n-            node += nodes.inline('', param.default, classes=['default_value'],\n+            node += nodes.inline('', str(param.default), classes=['default_value'],\n                                  support_smartquotes=False)\n \n         params += node\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8028", "model_patch": "diff --git a/sphinx/ext/autosummary/generate.py b/sphinx/ext/autosummary/generate.py\nindex ec986a0..be7b2ec 100644\n--- a/sphinx/ext/autosummary/generate.py\n+++ b/sphinx/ext/autosummary/generate.py\n@@ -221,8 +221,8 @@ class ModuleScanner:\n             if imported_members:\n                 # list all members up\n                 members.append(name)\n-            elif imported is False:\n-                # list not-imported members up\n+            elif imported is False or objtype == 'attribute':\n+                # list not-imported members and attributes up\n                 members.append(name)\n \n         return members\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8056", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex f955f19..b018b76 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1091,16 +1091,20 @@ class NumpyDocstring(GoogleDocstring):\n                        ) -> Tuple[str, str, List[str]]:\n         line = next(self._line_iter)\n         if parse_type:\n-            _name, _, _type = self._partition_field_on_colon(line)\n+            names_and_types = self._partition_field_on_colon(line)[0].split(', ')\n+            _type = self._partition_field_on_colon(line)[2]\n         else:\n-            _name, _type = line, ''\n-        _name, _type = _name.strip(), _type.strip()\n-        _name = self._escape_args_and_kwargs(_name)\n+            names_and_types = line.split(', ')\n+            _type = ''\n+        _name, _type = ', '.join(name.strip() for name in names_and_types), _type.strip()\n+        _names = [self._escape_args_and_kwargs(name) for name in names_and_types]\n         _type = _convert_numpy_type_spec(\n             _type,\n             location=self._get_location(),\n             translations=self._config.napoleon_type_aliases or {},\n         )\n+        for name in _names:\n+            push_item(name, rest)\n \n         if prefer_type and not _type:\n             _type, _name = _name, _type\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8075", "model_patch": "diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py\nindex 10ec4c1..bf75d99 100644\n--- a/sphinx/writers/latex.py\n+++ b/sphinx/writers/latex.py\n@@ -1325,6 +1325,9 @@ class LaTeXTranslator(SphinxTranslator):\n             self.body.append('\\n\\\\begin{figure}[%s]\\n\\\\centering\\n' % align)\n             if any(isinstance(child, nodes.caption) for child in node):\n                 self.body.append('\\\\capstart\\n')\n+            else:\n+                if self.builder.config.numfig:\n+                    self.body.append('\\\\caption*{Figure}\\n')  # Add a default caption for LaTeX\n             self.context.append('\\\\end{figure}\\n')\n \n     def depart_figure(self, node: Element) -> None:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8120", "model_patch": "diff --git a/sphinx/config.py b/sphinx/config.py\nindex fbf72e8..02107ad 100644\n--- a/sphinx/config.py\n+++ b/sphinx/config.py\n@@ -107,7 +107,7 @@ class Config:\n         'today_fmt': (None, 'env', [str]),\n \n         'language': (None, 'env', [str]),\n-        'locale_dirs': (['locales'], 'env', []),\n+        'locale_dirs': (['locale/'], 'env', []),\n         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n \n         'master_doc': ('index', 'env', []),\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8265", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex facb103..ca07cdb 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -1090,10 +1090,10 @@ class NumpyDocstring(GoogleDocstring):\n     def _escape_args_and_kwargs(self, name: str) -> str:\n         func = super()._escape_args_and_kwargs\n \n-        if \", \" in name:\n-            return \", \".join(func(param) for param in name.split(\", \"))\n-        else:\n-            return func(name)\n+        # Use regex to split on commas not within parentheses or brackets\n+        import re\n+        pattern = r',\\s*(?![^()]*\\))'\n+        return \", \".join(func(param) for param in re.split(pattern, name))\n \n     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n                        ) -> Tuple[str, str, List[str]]:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8278", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 71b6f3a..c121333 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -202,7 +202,16 @@ def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_\n                 node += nodes.Text(' ')\n             else:\n                 node += addnodes.desc_sig_operator('', '=')\n-            node += nodes.inline('', param.default, classes=['default_value'],\n+            default_value = param.default\n+            # Check if the default value is a hexadecimal number\n+            if isinstance(param.default, str) and param.default.startswith(('0x', '0X')):\n+                try:\n+                    # Convert to int to ensure it's a valid hexadecimal and then back to hex str\n+                    default_value = hex(int(param.default, 16))\n+                except ValueError:\n+                    # If it's not a valid hexadecimal, keep it as is\n+                    pass\n+            node += nodes.inline('', default_value, classes=['default_value'],\n                                  support_smartquotes=False)\n \n         params += node\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8620", "model_patch": "diff --git a/sphinx/writers/html.py b/sphinx/writers/html.py\nindex 30db1c2..3cca3dc 100644\n--- a/sphinx/writers/html.py\n+++ b/sphinx/writers/html.py\n@@ -494,8 +494,12 @@ class HTMLTranslator(SphinxTranslator, BaseTranslator):\n     # overwritten\n     def visit_literal(self, node: Element) -> None:\n         if 'kbd' in node['classes']:\n-            self.body.append(self.starttag(node, 'kbd', '',\n-                                           CLASS='docutils literal notranslate'))\n+            if '+' in node.rawsource:\n+                self.body.append(self.starttag(node, 'kbd', '',\n+                                               CLASS='docutils literal notranslate compound'))\n+            else:\n+                self.body.append(self.starttag(node, 'kbd', '',\n+                                               CLASS='docutils literal notranslate'))\n         else:\n             self.body.append(self.starttag(node, 'code', '',\n                                            CLASS='docutils literal notranslate'))\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8621", "model_patch": "diff --git a/sphinx/writers/html.py b/sphinx/writers/html.py\nindex 30db1c2..ef95cf1 100644\n--- a/sphinx/writers/html.py\n+++ b/sphinx/writers/html.py\n@@ -679,16 +679,20 @@ class HTMLTranslator(SphinxTranslator, BaseTranslator):\n         if self.protect_literal_text:\n             # moved here from base class's visit_literal to support\n             # more formatting in literal nodes\n-            for token in self.words_and_spaces.findall(encoded):\n-                if token.strip():\n-                    # protect literal text from line wrapping\n-                    self.body.append('<span class=\"pre\">%s</span>' % token)\n-                elif token in ' \\n':\n-                    # allow breaks at whitespace\n-                    self.body.append(token)\n-                else:\n-                    # protect runs of multiple spaces; the last one can wrap\n-                    self.body.append('&#160;' * (len(token) - 1) + ' ')\n+            if 'kbd' in node.parent['classes']:\n+                # treat the entire text as a single kbd element if parent is kbd\n+                self.body.append('<kbd class=\"kbd docutils literal notranslate\">%s</kbd>' % encoded)\n+            else:\n+                for token in self.words_and_spaces.findall(encoded):\n+                    if token.strip():\n+                        # protect literal text from line wrapping\n+                        self.body.append('<span class=\"pre\">%s</span>' % token)\n+                    elif token in ' \\n':\n+                        # allow breaks at whitespace\n+                        self.body.append(token)\n+                    else:\n+                        # protect runs of multiple spaces; the last one can wrap\n+                        self.body.append('&#160;' * (len(token) - 1) + ' ')\n         else:\n             if self.in_mailto and self.settings.cloak_email_addresses:\n                 encoded = self.cloak_email(encoded)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex ec7a051..53a9123 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1169,11 +1169,13 @@ class PythonDomain(Domain):\n                 return []\n             elif classname and classname + '.' + name in self.objects:\n                 newname = classname + '.' + name\n-            elif modname and modname + '.' + name in self.objects:\n-                newname = modname + '.' + name\n             elif modname and classname and \\\n                     modname + '.' + classname + '.' + name in self.objects:\n                 newname = modname + '.' + classname + '.' + name\n+            elif modname and modname + '.' + name in self.objects:\n+                newname = modname + '.' + name\n+            elif not modname and not classname and name in self.objects:\n+                newname = name\n         if newname is not None:\n             matches.append((newname, self.objects[newname]))\n         return matches\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8658", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex c58ca7f..075e134 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -551,9 +551,12 @@ class GoogleDocstring:\n                     # otherwise, assume entry is container;\n                     # [0] is new section, [1] is the section to alias.\n                     # in the case of key mismatch, just handle as generic section.\n-                    self._sections[entry[0].lower()] = \\\n-                        self._sections.get(entry[1].lower(),\n-                                           self._parse_custom_generic_section)\n+                    section_name = entry[0].lower()\n+                    alias_section = entry[1].lower()\n+                    if alias_section in self._sections:\n+                        self._sections[section_name] = self._sections[alias_section]\n+                    else:\n+                        self._sections[section_name] = self._parse_custom_generic_section\n \n     def _parse(self) -> None:\n         self._parsed_lines = self._consume_empty()\n@@ -638,8 +641,16 @@ class GoogleDocstring:\n         return self._parse_generic_section(label, use_admonition)\n \n     def _parse_custom_generic_section(self, section: str) -> List[str]:\n-        # for now, no admonition for simple custom sections\n-        return self._parse_generic_section(section, False)\n+        # Check if the section needs to be renamed\n+        if self._config.napoleon_custom_section_rename is False:\n+            return self._parse_generic_section(section, False)\n+        else:\n+            # Find the original section name in the config\n+            for entry in self._config.napoleon_custom_sections:\n+                if isinstance(entry, tuple) and entry[0].lower() == section.lower():\n+                    section = entry[1]\n+                    break\n+            return self._parse_generic_section(section, False)\n \n     def _parse_usage_section(self, section: str) -> List[str]:\n         header = ['.. rubric:: Usage:', '']\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9229", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex b8c505d..d2c5757 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -649,6 +649,13 @@ class PyVariable(PyObject):\n \n         return fullname, prefix\n \n+    def add_content(self, more_content: Iterable[nodes.Node], no_docstring: bool = False) -> None:\n+        super().add_content(more_content, no_docstring)\n+        if not no_docstring:\n+            docstring = inspect.getdoc(self.object)\n+            if docstring:\n+                self.state.nested_parse(StringList(docstring.split('\\n')), 0, self.content)\n+\n     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n         name, cls = name_cls\n         if modname:\n@@ -1396,4 +1403,5 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n         'env_version': 3,\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n-    }\n+    }\n+\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9230", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..8c60dee 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -940,12 +940,27 @@ def _tokenize_type_spec(spec: str) -> List[str]:\n         else:\n             return [item]\n \n-    tokens = list(\n-        item\n-        for raw_token in _token_regex.split(spec)\n-        for item in postprocess(raw_token)\n-        if item\n-    )\n+    tokens = []\n+    i = 0\n+    while i < len(spec):\n+        if spec[i] == '(':\n+            tokens.append('(')\n+            j = i + 1\n+            balance = 1\n+            while j < len(spec) and balance > 0:\n+                if spec[j] == '(':\n+                    balance += 1\n+                elif spec[j] == ')':\n+                    balance -= 1\n+                j += 1\n+            tokens.append(spec[i+1:j-1])\n+            tokens.append(')')\n+            i = j\n+        else:\n+            raw_token = _token_regex.split(spec[i:])[0]\n+            tokens.extend(postprocess(raw_token))\n+            i += len(raw_token)\n+    tokens = [item for item in tokens if item]\n     return tokens\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9289", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 51811ca..5d4214b 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -130,6 +130,7 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n def augment_descriptions_with_types(\n     node: nodes.field_list,\n     annotations: Dict[str, str],\n+    config: Config,\n ) -> None:\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n@@ -161,7 +162,10 @@ def augment_descriptions_with_types(\n         if name in has_description and name not in has_type:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n-            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n+            from sphinx.util.typing import stringify\n+            if config.python_use_unqualified_type_names:\n+                annotation = stringify(eval(annotations[name]))\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n \n     # Add 'rtype' if 'return' is present and 'rtype' isn't.\n@@ -169,7 +173,10 @@ def augment_descriptions_with_types(\n         if 'return' in has_description and 'return' not in has_type:\n             field = nodes.field()\n             field += nodes.field_name('', 'rtype')\n-            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            from sphinx.util.typing import stringify\n+            if config.python_use_unqualified_type_names:\n+                annotation = stringify(eval(annotations['return']))\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..ac97e44 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -223,7 +223,7 @@ def ask_user(d: Dict) -> None:\n         print(__('sphinx-quickstart will not overwrite existing Sphinx projects.'))\n         print()\n         d['path'] = do_prompt(__('Please enter a new root path (or just Enter to exit)'),\n-                              '', is_path)\n+                              '', ok)\n         if not d['path']:\n             sys.exit(1)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9350", "model_patch": "diff --git a/sphinx/roles.py b/sphinx/roles.py\nindex 4c3badf..1931a97 100644\n--- a/sphinx/roles.py\n+++ b/sphinx/roles.py\n@@ -306,7 +306,7 @@ class EmphasizedLiteral(SphinxRole):\n                     stack = ['']\n                 else:\n                     # emphasized word not found; the rparen is not a special symbol\n-                    stack.append('}')\n+                    stack[-1] += '}'\n                     stack = [''.join(stack)]\n             elif part == '\\\\{':  # escaped left-brace\n                 stack[-1] += '{'\n@@ -320,6 +320,10 @@ class EmphasizedLiteral(SphinxRole):\n             text = ''.join(stack)\n             result.append(nodes.Text(text, text))\n \n+        # Ensure that the stack is properly reset after parsing\n+        if stack and stack[0]:\n+            result.append(nodes.Text(stack[0], stack[0]))\n+\n         return result\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9464", "model_patch": "diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\nindex 7d0ed59..0c23615 100644\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -337,6 +337,16 @@ def _stringify_py37(annotation: Any) -> str:\n     elif hasattr(annotation, '__origin__'):\n         # instantiated generic provided by a user\n         qualname = stringify(annotation.__origin__)\n+        if getattr(annotation, '__args__', None):\n+            if not isinstance(annotation.__args__, (list, tuple)):\n+                # broken __args__ found\n+                pass\n+            elif all(is_system_TypeVar(a) for a in annotation.__args__):\n+                # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n+                return qualname\n+            else:\n+                args = ', '.join(stringify(a) for a in annotation.__args__)\n+                return '%s[%s]' % (qualname, args)\n     elif types_Union and isinstance(annotation, types_Union):  # types.Union (for py3.10+)\n         qualname = 'types.Union'\n     else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9673", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..89129e4 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -772,7 +772,7 @@ class GoogleDocstring:\n         if multi:\n             use_rtype = False\n         else:\n-            use_rtype = self._config.napoleon_use_rtype\n+            use_rtype = self._config.napoleon_use_rtype or self._config.autodoc_typehints_description_target == \"documented\"\n \n         lines: List[str] = []\n         for _name, _type, _desc in fields:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9797", "model_patch": "diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex cb48248..813f61a 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -281,7 +281,16 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n             unmangled = unmangle(subject, name)\n             if unmangled and unmangled not in members:\n                 if name in obj_dict:\n-                    members[unmangled] = ObjectMember(unmangled, value, class_=subject)\n+                    docstring = safe_getattr(value, '__doc__', None)\n+                    if docstring is None:\n+                        # Inherit docstring from parent class if not present in child class\n+                        for cls in getmro(subject)[1:]:  # Skip the class itself\n+                            parent_value = safe_getattr(cls, name, None)\n+                            if parent_value is not None:\n+                                docstring = safe_getattr(parent_value, '__doc__', None)\n+                                if docstring is not None:\n+                                    break\n+                    members[unmangled] = ObjectMember(unmangled, value, class_=subject, docstring=docstring)\n                 else:\n                     members[unmangled] = ObjectMember(unmangled, value)\n         except AttributeError:\n@@ -321,4 +330,4 @@ def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable\n     except AttributeError:\n         pass\n \n-    return members\n+    return members\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9982", "model_patch": "diff --git a/sphinx/util/logging.py b/sphinx/util/logging.py\nindex 2c96388..67c9f44 100644\n--- a/sphinx/util/logging.py\n+++ b/sphinx/util/logging.py\n@@ -49,7 +49,7 @@ VERBOSITY_MAP.update({\n COLOR_MAP = defaultdict(lambda: 'blue',\n                         {\n                             logging.ERROR: 'darkred',\n-                            logging.WARNING: 'red',\n+                            logging.WARNING: 'lightred',\n                             logging.DEBUG: 'darkgray'\n                         })\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9987", "model_patch": "diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex ea465e6..a5c7af3 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -623,6 +623,13 @@ class GoogleDocstring:\n         lines = self._format_field('', '', _desc)\n         if _type:\n             lines.extend(['', ':type: %s' % _type])\n+        elif self._what == 'class' and self._obj:\n+            # Try to find annotations for properties in the class\n+            _annotations = get_type_hints(self._obj, include_extras=True)\n+            for attr in _annotations:\n+                if self._name == attr:\n+                    lines.extend(['', ':type: %s' % stringify_annotation(_annotations[attr])])\n+                    break\n         return lines\n \n     def _parse_attributes_section(self, section: str) -> List[str]:\n@@ -630,6 +637,11 @@ class GoogleDocstring:\n         for _name, _type, _desc in self._consume_fields():\n             if not _type:\n                 _type = self._lookup_annotation(_name)\n+            if not _type and self._what == 'class' and self._obj:\n+                # Try to find annotations for properties in the class\n+                _annotations = get_type_hints(self._obj, include_extras=True)\n+                if _name in _annotations:\n+                    _type = stringify_annotation(_annotations[_name])\n             if self._config.napoleon_use_ivar:\n                 _name = self._qualify_name(_name, self._obj)\n                 field = ':ivar %s: ' % _name\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9997", "model_patch": "diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py\nindex 9e4d85e..7b3cc76 100644\n--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -410,7 +410,7 @@ def _stringify_py37(annotation: Any, smartref: bool = False) -> str:\n             returns = stringify(annotation.__args__[-1], smartref)\n             return '%s%s[[%s], %s]' % (modprefix, qualname, args, returns)\n         elif qualname == 'Literal':\n-            args = ', '.join(repr(a) for a in annotation.__args__)\n+            args = ', '.join(stringify(a, smartref) for a in annotation.__args__)\n             return '%s%s[%s]' % (modprefix, qualname, args)\n         elif str(annotation).startswith('typing.Annotated'):  # for py39+\n             return stringify(annotation.__args__[0], smartref)\n@@ -494,4 +494,4 @@ deprecated_alias('sphinx.util.typing',\n                  {\n                      'DirectiveOption': Callable[[str], Any],\n                  },\n-                 RemovedInSphinx60Warning)\n+                 RemovedInSphinx60Warning)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9999", "model_patch": "diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py\nindex 4fa0d3d..d875e9a 100644\n--- a/sphinx/builders/latex/transforms.py\n+++ b/sphinx/builders/latex/transforms.py\n@@ -392,6 +392,7 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):\n \n     def visit_term(self, node: nodes.term) -> None:\n         self.restrict(node)\n+        self.body.append('\\n')  # Ensure a new line is added after each term\n \n     def depart_term(self, node: nodes.term) -> None:\n         self.unrestrict(node)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11787", "model_patch": "diff --git a/sympy/solvers/solvers.py b/sympy/solvers/solvers.py\nindex 60703ea..bbb1e3e 100644\n--- a/sympy/solvers/solvers.py\n+++ b/sympy/solvers/solvers.py\n@@ -2765,6 +2765,7 @@ def nsolve(*args, **kwargs):\n         f = f.as_numer_denom()[0]\n \n         f = lambdify(fargs, f, modules)\n+        print(f\"Function evaluated at initial guess: {f(x0)}\")\n         return Float(findroot(f, x0, **kwargs))\n \n     if len(fargs) > f.cols:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d19d26f..5ecd95a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1452,7 +1452,7 @@ class LatexPrinter(Printer):\n     def _print_SingularityFunction(self, expr):\n         shift = self._print(expr.args[0] - expr.args[1])\n         power = self._print(expr.args[2])\n-        tex = r\"{\\langle %s \\rangle}^ %s\" % (shift, power)\n+        tex = r\"{\\langle %s \\rangle}^{%s}\" % (shift, power)\n         return tex\n \n     def _print_Heaviside(self, expr, exp=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-13840", "model_patch": "diff --git a/sympy/printing/codeprinter.py b/sympy/printing/codeprinter.py\nindex 42e508f..eaa8237 100644\n--- a/sympy/printing/codeprinter.py\n+++ b/sympy/printing/codeprinter.py\n@@ -453,7 +453,7 @@ class CodePrinter(StrPrinter):\n         return self.emptyPrinter(expr)\n \n     # The following can not be simply translated into C or Fortran\n-    _print_Basic = _print_not_supported\n+    # _print_Basic = _print_not_supported\n     _print_ComplexInfinity = _print_not_supported\n     _print_Derivative = _print_not_supported\n     _print_ExprCondPair = _print_not_supported\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15151", "model_patch": "diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex f3c0235..ed38466 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1081,6 +1081,11 @@ class PrettyPrinter(Printer):\n         from sympy.functions.elementary.piecewise import Piecewise\n         return self._print(ite.rewrite(Piecewise))\n \n+    def _print_Indexed(self, expr):\n+        base = self._print(expr.base)\n+        indices = ','.join(map(self._print, expr.indices))\n+        return prettyForm(base + '_{' + indices + '}')\n+\n     def _hprint_vec(self, v):\n         D = None\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15304", "model_patch": "diff --git a/sympy/physics/continuum_mechanics/beam.py b/sympy/physics/continuum_mechanics/beam.py\nindex 4907451..6f3cf81 100644\n--- a/sympy/physics/continuum_mechanics/beam.py\n+++ b/sympy/physics/continuum_mechanics/beam.py\n@@ -394,7 +394,7 @@ class Beam(object):\n             if order == 0:\n                 self._load -= value*SingularityFunction(x, end, order)\n             elif order.is_positive:\n-                self._load -= value*SingularityFunction(x, end, order) + value*SingularityFunction(x, end, 0)\n+                self._load -= value*SingularityFunction(x, end, order)\n             else:\n                 raise ValueError(\"\"\"Order of the load should be positive.\"\"\")\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-15976", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 85af872..714363a 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -767,10 +767,7 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n \n         # translate name, supers and subs to unicode characters\n         def translate(s):\n-            if s in greek_unicode:\n-                return greek_unicode.get(s)\n-            else:\n-                return s\n+            return s  # Avoid modifying the symbol name if it doesn't contain Greek letters\n \n         name, supers, subs = split_super_sub(sym.name)\n         name = translate(name)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-16003", "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 85af872..53b9cda 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -840,38 +840,49 @@ class MathMLPresentationPrinter(MathMLPrinterBase):\n \n     def _print_Derivative(self, e):\n         mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mo')\n         if requires_partial(e):\n-            x.appendChild(self.dom.createTextNode('&#x2202;'))\n-            y = self.dom.createElement('mo')\n-            y.appendChild(self.dom.createTextNode('&#x2202;'))\n+            numerator_symbol = '&#x2202;'\n         else:\n-            x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            y = self.dom.createElement('mo')\n-            y.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-\n-        brac = self.dom.createElement('mfenced')\n-        brac.appendChild(self._print(e.expr))\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(x)\n-        mrow.appendChild(brac)\n-\n-        for sym in e.variables:\n-            frac = self.dom.createElement('mfrac')\n-            m = self.dom.createElement('mrow')\n-            x = self.dom.createElement('mo')\n-            if requires_partial(e):\n-                x.appendChild(self.dom.createTextNode('&#x2202;'))\n+            numerator_symbol = 'd'\n+        \n+        # Create the numerator with the superscript if necessary\n+        numerator = self.dom.createElement('mfrac')\n+        num_mrow = self.dom.createElement('mrow')\n+        num_mo = self.dom.createElement('mo')\n+        num_mo.appendChild(self.dom.createTextNode(numerator_symbol))\n+        num_mrow.appendChild(num_mo)\n+        num_msup = self.dom.createElement('msup')\n+        num_msup.appendChild(num_mo)\n+        num_msup.appendChild(self.dom.createTextNode(str(len(e.variables))))\n+        \n+        # Create the denominator\n+        denom_mrow = self.dom.createElement('mrow')\n+        variable_count = e.variable_count\n+        for sym, num in variable_count:\n+            denom_mo = self.dom.createElement('mo')\n+            denom_mo.appendChild(self.dom.createTextNode(numerator_symbol))\n+            denom_mrow.appendChild(denom_mo)\n+            if num == 1:\n+                denom_mrow.appendChild(self._print(sym))\n             else:\n-                x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            y = self._print(sym)\n-            m.appendChild(x)\n-            m.appendChild(y)\n-            frac.appendChild(mrow)\n-            frac.appendChild(m)\n-            mrow = frac\n-\n-        return frac\n+                denom_msup = self.dom.createElement('msup')\n+                denom_msup.appendChild(self._print(sym))\n+                denom_msup.appendChild(self.dom.createTextNode(str(num)))\n+                denom_mrow.appendChild(denom_msup)\n+        \n+        # Create the final fraction\n+        numerator.appendChild(num_mrow)\n+        numerator.appendChild(denom_mrow)\n+        mrow.appendChild(numerator)\n+        \n+        # Create the function part on a separate line\n+        func_mrow = self.dom.createElement('mrow')\n+        func_brac = self.dom.createElement('mfenced')\n+        func_brac.appendChild(self._print(e.expr))\n+        func_mrow.appendChild(func_brac)\n+        mrow.appendChild(func_mrow)\n+        \n+        return mrow\n \n     def _print_Function(self, e):\n         mrow = self.dom.createElement('mrow')\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17067", "model_patch": "diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py\nindex 6a8214a..a219267 100644\n--- a/sympy/functions/elementary/trigonometric.py\n+++ b/sympy/functions/elementary/trigonometric.py\n@@ -1401,6 +1401,11 @@ class cot(TrigonometricFunction):\n         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)\n         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)\n \n+    def _eval_rewrite_as_sin_cos(self, arg, **kwargs):\n+        sin_expr = sin(arg, evaluate=False)\n+        cos_expr = cos(arg, evaluate=False)\n+        return sin_expr / cos_expr\n+\n     def _eval_rewrite_as_Pow(self, arg, **kwargs):\n         if isinstance(arg, log):\n             I = S.ImaginaryUnit\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-17115", "model_patch": "diff --git a/sympy/functions/elementary/piecewise.py b/sympy/functions/elementary/piecewise.py\nindex 2558a3b..8cf8e3c 100644\n--- a/sympy/functions/elementary/piecewise.py\n+++ b/sympy/functions/elementary/piecewise.py\n@@ -176,7 +176,7 @@ class Piecewise(Function):\n         # make conditions canonical\n         args = []\n         for e, c in _args:\n-            if not c.is_Atom and not isinstance(c, Relational):\n+            if not c.is_Atom and not isinstance(c, (Relational, Boolean)):\n                 free = c.free_symbols\n                 if len(free) == 1:\n                     funcs = [i for i in c.atoms(Function)\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-18922", "model_patch": "diff --git a/sympy/plotting/plot.py b/sympy/plotting/plot.py\nindex cce65e7..02a061b 100644\n--- a/sympy/plotting/plot.py\n+++ b/sympy/plotting/plot.py\n@@ -682,8 +682,11 @@ class LineOver1DRangeSeries(Line2DBaseSeries):\n                 list_x = np.logspace(self.start, self.end, num=self.nb_of_points)\n             else:\n                 list_x = np.linspace(self.start, self.end, num=self.nb_of_points)\n-        f = vectorized_lambdify([self.var], self.expr)\n-        list_y = f(list_x)\n+        if self.expr.is_constant():\n+            list_y = np.full_like(list_x, self.expr)\n+        else:\n+            f = vectorized_lambdify([self.var], self.expr)\n+            list_y = f(list_x)\n         return (list_x, list_y)\n \n class Parametric2DLineSeries(Line2DBaseSeries):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21769", "model_patch": "diff --git a/sympy/physics/quantum/cg.py b/sympy/physics/quantum/cg.py\nindex ae6b99a..444861f 100644\n--- a/sympy/physics/quantum/cg.py\n+++ b/sympy/physics/quantum/cg.py\n@@ -218,7 +218,7 @@ class CG(Wigner3j):\n     def _latex(self, printer, *args):\n         label = map(printer._print, (self.j3, self.m3, self.j1,\n                     self.m1, self.j2, self.m2))\n-        return r'C^{%s,%s}_{%s,%s,%s,%s}' % tuple(label)\n+        return r'{C^{%s,%s}_{%s,%s,%s,%s}}' % tuple(label)\n \n \n class Wigner6j(Expr):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-4083", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex a2d5367..e17850b 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -2108,6 +2108,8 @@ def make_figure(args, constructor, trace_patch=None, layout_patch=None):\n                             showscale=False,\n                             showlegend=True,\n                         )\n+                    elif m.variable == \"hover_data\" and not isinstance(m.val_map[val], list):\n+                        raise ValueError(f\"Looks like you supplied a single column name, you should supply a list of columns. Expected one of {list(args['data_frame'].columns)} but received: {m.val_map[val]}\")\n                     else:\n                         raise\n \n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-2600", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 723f514..f7fe9dd 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -577,7 +577,7 @@ def configure_cartesian_marginal_axes(args, fig, orders):\n \n     # Configure axis type across all y-axes\n     if \"log_y\" in args and args[\"log_y\"]:\n-        fig.update_yaxes(type=\"log\")\n+        fig.update_yaxes(type=\"log\", row=1, col=1)  # Only apply to main plot\n \n     # Configure matching and axis type for marginal y-axes\n     matches_y = \"y\" + str(ncols + 1)\n@@ -589,6 +589,10 @@ def configure_cartesian_marginal_axes(args, fig, orders):\n         for col in range(2, ncols + 1, 2):\n             fig.update_xaxes(matches=\"x2\", type=None, col=col)\n \n+    # Set range for the main y-axis only\n+    if \"range_y\" in args and args[\"range_y\"]:\n+        fig.update_yaxes(range=args[\"range_y\"], row=1, col=1)\n+\n \n def configure_cartesian_axes(args, fig, orders):\n     if (\"marginal_x\" in args and args[\"marginal_x\"]) or (\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-2591", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 8ada692..97f381f 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1507,7 +1507,7 @@ def process_dataframe_hierarchy(args):\n \n         if args[\"color\"]:\n             if args[\"color\"] == args[\"values\"]:\n-                aggfunc_color = \"sum\"\n+                aggfunc_color = \"mean\"\n         count_colname = args[\"values\"]\n     else:\n         # we need a count column for the first groupby and the weighted mean of color\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-1966", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 897ecfd..5529635 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1267,7 +1267,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"row\":\n                     row = m.val_map[val]\n                     if args[\"facet_row\"] and len(row_labels) < row:\n-                        row_labels.append(args[\"facet_row\"] + \"=\" + str(val))\n+                        row_labels.append(get_label(args, args[\"facet_row\"]) + \"=\" + str(val))\n                 else:\n                     if (\n                         bool(args.get(\"marginal_x\", False))\n@@ -1282,7 +1282,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"col\":\n                     col = m.val_map[val]\n                     if args[\"facet_col\"] and len(col_labels) < col:\n-                        col_labels.append(args[\"facet_col\"] + \"=\" + str(val))\n+                        col_labels.append(get_label(args, args[\"facet_col\"]) + \"=\" + str(val))\n                     if facet_col_wrap:  # assumes no facet_row, no marginals\n                         row = 1 + ((col - 1) // facet_col_wrap)\n                         col = 1 + ((col - 1) % facet_col_wrap)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6503", "model_patch": "diff --git a/networkx/algorithms/tree/operations.py b/networkx/algorithms/tree/operations.py\nindex dfa8a5c..42c8840 100644\n--- a/networkx/algorithms/tree/operations.py\n+++ b/networkx/algorithms/tree/operations.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Operations on trees.\"\"\"\n from functools import partial\n from itertools import accumulate, chain\n@@ -82,10 +83,11 @@ def join(rooted_trees, label_attribute=None):\n         for tree, root in zip(trees, roots)\n     ]\n \n-    # Remove the old node labels.\n-    for tree in trees:\n-        for v in tree:\n-            tree.nodes[v].pop(\"_old\")\n+    # Remove the old node labels only if label_attribute is not provided.\n+    if label_attribute is None:\n+        for tree in trees:\n+            for v in tree:\n+                tree.nodes[v].pop(\"_old\")\n \n     # Add all sets of nodes and edges, with data.\n     nodes = (tree.nodes(data=True) for tree in trees)\n@@ -103,4 +105,4 @@ def join(rooted_trees, label_attribute=None):\n     R.add_node(0)\n     R.add_edges_from((0, root) for root in roots)\n \n-    return R\n+    return R\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6098", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 563968a..43e7e2d 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -657,9 +657,9 @@ def draw_networkx_edges(\n         else:\n             arrowstyle = \"-\"\n \n-    use_linecollection = not G.is_directed()\n+    use_linecollection = not G.is_directed() and connectionstyle == \"arc3\"\n     if arrows in (True, False):\n-        use_linecollection = not arrows\n+        use_linecollection = not arrows and connectionstyle == \"arc3\"\n \n     if ax is None:\n         ax = plt.gca()\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5616", "model_patch": "diff --git a/networkx/algorithms/euler.py b/networkx/algorithms/euler.py\nindex 5b844cf..c350085 100644\n--- a/networkx/algorithms/euler.py\n+++ b/networkx/algorithms/euler.py\n@@ -287,6 +287,12 @@ def has_eulerian_path(G, source=None):\n             unbalanced_ins <= 1 and unbalanced_outs <= 1 and nx.is_weakly_connected(G)\n         )\n     else:\n+        # Remove isolated nodes (if any) without altering the input graph\n+        nodes_remove = [v for v in G if G.degree[v] == 0]\n+        if nodes_remove:\n+            G = G.copy()\n+            G.remove_nodes_from(nodes_remove)\n+\n         # We know it is not eulerian, so degree of source must be odd.\n         if source is not None and G.degree[source] % 2 != 1:\n             return False\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5354", "model_patch": "diff --git a/networkx/drawing/layout.py b/networkx/drawing/layout.py\nindex 8e512fb..a44a46d 100644\n--- a/networkx/drawing/layout.py\n+++ b/networkx/drawing/layout.py\n@@ -1002,9 +1002,9 @@ def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=F\n     if equidistant:\n         chord = 1\n         step = 0.5\n-        theta = resolution\n-        for _ in range(len(G)):\n-            r = step * theta\n+        theta = 0\n+        for i in range(len(G)):\n+            r = step * (i + 1)\n             theta += chord / r\n             pos.append([np.cos(theta) * r, np.sin(theta) * r])\n \n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5058", "model_patch": "diff --git a/networkx/readwrite/graphml.py b/networkx/readwrite/graphml.py\nindex 523e516..d786ffe 100644\n--- a/networkx/readwrite/graphml.py\n+++ b/networkx/readwrite/graphml.py\n@@ -509,10 +509,18 @@ class GraphMLWriter(GraphML):\n                     return str\n                 elif \"float\" in types or \"double\" in types:\n                     return float\n-                else:\n+                elif \"int\" in types:\n                     return int\n+                elif \"list\" in types:\n+                    return list\n+                else:\n+                    return str  # Default to string if type is unknown\n             else:\n-                return list(types)[0]\n+                t = list(types)[0]\n+                if t is list:\n+                    return list\n+                else:\n+                    return self.xml_type[t]\n         else:\n             return type(value)\n \n@@ -548,9 +556,13 @@ class GraphMLWriter(GraphML):\n         type in the keys table.\n         \"\"\"\n         if element_type not in self.xml_type:\n-            raise nx.NetworkXError(\n-                f\"GraphML writer does not support {element_type} as data values.\"\n-            )\n+            if element_type is list:\n+                element_type = str\n+                value = str(value)  # Convert list to string representation\n+            else:\n+                raise nx.NetworkXError(\n+                    f\"GraphML writer does not support {element_type} as data values.\"\n+                )\n         keyid = self.get_key(name, self.xml_type[element_type], scope, default)\n         data_element = self.myElement(\"data\", key=keyid)\n         data_element.text = str(value)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..db0b201 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -628,6 +628,10 @@ def draw_networkx_edges(\n     if edgelist is None:\n         edgelist = list(G.edges())\n \n+    if nodelist is not None:\n+        # Filter edgelist to include only edges between nodes in nodelist\n+        edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n+\n     if len(edgelist) == 0:  # no edges!\n         return []\n \n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-2785", "model_patch": "diff --git a/altair/vegalite/v5/theme.py b/altair/vegalite/v5/theme.py\nindex 12f32cd..1fff7b2 100644\n--- a/altair/vegalite/v5/theme.py\n+++ b/altair/vegalite/v5/theme.py\n@@ -22,7 +22,7 @@ class VegaTheme(object):\n     def __call__(self):\n         return {\n             \"usermeta\": {\"embedOptions\": {\"theme\": self.theme}},\n-            \"config\": {\"view\": {\"continuousWidth\": 400, \"continuousHeight\": 300}},\n+            \"config\": {\"view\": {\"continuousWidth\": 300, \"continuousHeight\": 300}},\n         }\n \n     def __repr__(self):\n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-1092", "model_patch": "diff --git a/altair/utils/data.py b/altair/utils/data.py\nindex 64634d6..814ea7a 100644\n--- a/altair/utils/data.py\n+++ b/altair/utils/data.py\n@@ -131,6 +131,9 @@ def to_values(data):\n     elif isinstance(data, dict):\n         if 'values' not in data:\n             raise KeyError('values expected in data dict, but not present.')\n+        # Preserve the format property if present\n+        if 'format' in data:\n+            return {'values': data['values'], 'format': data['format']}\n         return data\n \n \n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-974", "model_patch": "diff --git a/altair/utils/data.py b/altair/utils/data.py\nindex 26f1390..2b7fd98 100644\n--- a/altair/utils/data.py\n+++ b/altair/utils/data.py\n@@ -145,6 +145,9 @@ def _data_to_json_string(data):\n     check_data_type(data)\n     if isinstance(data, pd.DataFrame):\n         data = sanitize_dataframe(data)\n+        # Convert Timedelta objects to string\n+        for col in data.select_dtypes(include=[pd.Timedelta]).columns:\n+            data[col] = data[col].astype(str)\n         return data.to_json(orient='records')\n     elif isinstance(data, dict):\n         if 'values' not in data:\n"}
{"model_name_or_path": "agentless", "instance_id": "vega__altair-830", "model_patch": "diff --git a/altair/vegalite/v2/api.py b/altair/vegalite/v2/api.py\nindex f380dc9..7a70fcb 100644\n--- a/altair/vegalite/v2/api.py\n+++ b/altair/vegalite/v2/api.py\n@@ -897,14 +897,17 @@ class EncodingMixin(object):\n                 return obj\n \n         for prop, obj in list(kwargs.items()):\n-            try:\n-                condition = obj['condition']\n-            except (KeyError, TypeError):\n-                pass\n+            if prop == 'tooltip' and isinstance(obj, list):\n+                kwargs[prop] = [_wrap_in_channel_class(item, prop) for item in obj]\n             else:\n-                if condition is not Undefined:\n-                    obj['condition'] = _wrap_in_channel_class(condition, prop)\n-            kwargs[prop] = _wrap_in_channel_class(obj, prop)\n+                try:\n+                    condition = obj['condition']\n+                except (KeyError, TypeError):\n+                    pass\n+                else:\n+                    if condition is not Undefined:\n+                        obj['condition'] = _wrap_in_channel_class(condition, prop)\n+                kwargs[prop] = _wrap_in_channel_class(obj, prop)\n \n \n         copy = self.copy(deep=True, ignore=['data'])\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-27754", "model_patch": "diff --git a/lib/matplotlib/quiver.py b/lib/matplotlib/quiver.py\nindex 6752bb3..95a543d 100644\n--- a/lib/matplotlib/quiver.py\n+++ b/lib/matplotlib/quiver.py\n@@ -537,6 +537,8 @@ class Quiver(mcollections.PolyCollection):\n         self._init()\n         verts = self._make_verts(self.XY, self.U, self.V, self.angles)\n         self.set_verts(verts, closed=False)\n+        if self._A is not None:\n+            self._A.set_array(self._C)\n         super().draw(renderer)\n         self.stale = False\n \n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26926", "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex c89d3d2..ef5833c 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -346,7 +346,7 @@ class Legend(Artist):\n \n     # 'best' is only implemented for axes legends\n     codes = {'best': 0, **AnchoredOffsetbox.codes}\n-    zorder = 5\n+    zorder = 10\n \n     def __str__(self):\n         return \"Legend\"\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-26788", "model_patch": "diff --git a/lib/matplotlib/projections/polar.py b/lib/matplotlib/projections/polar.py\nindex 5061f30..bc8708f 100644\n--- a/lib/matplotlib/projections/polar.py\n+++ b/lib/matplotlib/projections/polar.py\n@@ -850,6 +850,13 @@ class PolarAxes(Axes):\n         self.yaxis = RadialAxis(self, clear=False)\n         self.spines['polar'].register_axis(self.yaxis)\n \n+        # Ensure axhline behaves correctly on polar axes\n+        def axhline(self, y=0, xmin=0, xmax=1, **kwargs):\n+            line = super().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)\n+            if self.name == 'polar':\n+                line.get_path()._interpolation_steps = 180\n+            return line\n+\n     def _set_lim_and_transforms(self):\n         # A view limit where the minimum radius can be locked if the user\n         # specifies an alternate origin.\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-26941", "model_patch": "diff --git a/sympy/series/order.py b/sympy/series/order.py\nindex 2184335..cbf7389 100644\n--- a/sympy/series/order.py\n+++ b/sympy/series/order.py\n@@ -485,6 +485,9 @@ class Order(Expr):\n                             e1 = sol.args[0]\n                             e2 = sol.args[1]\n                             sol = set(e1) - set(e2)\n+                        # Ensure sol is iterable\n+                        if not isinstance(sol, (list, tuple, set)):\n+                            sol = [sol]\n                         res = [dict(zip((d, ), sol))]\n                         point = d.subs(res[0]).limit(old, self.point[i])\n                     newvars[i] = var\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3458", "model_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 685ce8a..4497b32 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1551,9 +1551,13 @@ class Plotter:\n \n             scales = self._scales.copy()\n             if x in out_df:\n-                scales[\"x\"] = self._scales[x]\n+                scales[\"x\"] = self._scales.get(x, self._scales.get(\"x\", Scale._identity()))\n             if y in out_df:\n-                scales[\"y\"] = self._scales[y]\n+                scales[\"y\"] = self._scales.get(y, self._scales.get(\"y\", Scale._identity()))\n+            if \"x\" in self._scales:\n+                scales[\"x\"] = self._scales[\"x\"]\n+            if \"y\" in self._scales:\n+                scales[\"y\"] = self._scales[\"y\"]\n \n             for axis, var in zip(\"xy\", (x, y)):\n                 if axis != var:\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3454", "model_patch": "diff --git a/seaborn/utils.py b/seaborn/utils.py\nindex ca63f83..2b1a644 100644\n--- a/seaborn/utils.py\n+++ b/seaborn/utils.py\n@@ -457,8 +457,8 @@ def move_legend(obj, loc, **kwargs):\n     # Extract the components of the legend we need to reuse\n     # Import here to avoid a circular import\n     from seaborn._compat import get_legend_handles\n-    handles = get_legend_handles(old_legend)\n-    labels = [t.get_text() for t in old_legend.get_texts()]\n+    handles = kwargs.pop('handles', get_legend_handles(old_legend))\n+    labels = kwargs.pop('labels', [t.get_text() for t in old_legend.get_texts()])\n \n     # Extract legend properties that can be passed to the recreation method\n     # (Vexingly, these don't all round-trip)\n"}
