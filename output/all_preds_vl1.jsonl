{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-11693", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex 775d166..7a64511 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1871,21 +1871,21 @@ reduce these to 2 dimensions using the naxis kwarg.\n         # ############################################################\n         if (ind is not None or inddiv is not None) and not quiet:\n             if inddiv is None:\n-                raise NoConvergence(\n-                    \"'WCS.all_world2pix' failed to \"\n-                    \"converge to the requested accuracy after {:d} \"\n-                    \"iterations.\".format(k), best_solution=pix,\n-                    accuracy=np.abs(dpix), niter=k,\n-                    slow_conv=ind, divergent=None)\n+                print(\"Solution failed to converge to the requested accuracy after {:d} iterations.\".format(k))\n+                print(\"Best solution:\", pix)\n+                print(\"Accuracy:\", np.abs(dpix))\n+                print(\"Number of iterations:\", k)\n+                print(\"Slow-converging points:\", ind)\n+                print(\"Divergent points:\", inddiv)\n             else:\n-                raise NoConvergence(\n-                    \"'WCS.all_world2pix' failed to \"\n-                    \"converge to the requested accuracy.\\n\"\n-                    \"After {:d} iterations, the solution is diverging \"\n-                    \"at least for one input point.\"\n-                    .format(k), best_solution=pix,\n-                    accuracy=np.abs(dpix), niter=k,\n-                    slow_conv=ind, divergent=inddiv)\n+                print(\"Solution failed to converge to the requested accuracy.\")\n+                print(\"After {:d} iterations, the solution is diverging\".format(k))\n+                print(\"At least for one input point.\")\n+                print(\"Best solution:\", pix)\n+                print(\"Accuracy:\", np.abs(dpix))\n+                print(\"Number of iterations:\", k)\n+                print(\"Slow-converging points:\", ind)\n+                print(\"Divergent points:\", inddiv)\n \n         return pix\n \n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13838", "model_patch": "diff --git a/astropy/table/pprint.py b/astropy/table/pprint.py\nindex 2d557c7..e1b1780 100644\n--- a/astropy/table/pprint.py\n+++ b/astropy/table/pprint.py\n@@ -476,13 +476,22 @@ class TableFormatter:\n                 # with shape (n,1,...,1) from being printed as if there was\n                 # more than one element in a row\n                 if trivial_multidims:\n-                    return format_func(col_format, col[(idx,) + multidim0])\n+                    if col.shape[1] > 0:\n+                        return format_func(col_format, col[(idx,) + multidim0])\n+                    else:\n+                        return ''\n                 else:\n-                    left = format_func(col_format, col[(idx,) + multidim0])\n-                    right = format_func(col_format, col[(idx,) + multidim1])\n-                    return f'{left} .. {right}'\n+                    if col.shape[1] > 0:\n+                        left = format_func(col_format, col[(idx,) + multidim0])\n+                        right = format_func(col_format, col[(idx,) + multidim1])\n+                        return f'{left} .. {right}'\n+                    else:\n+                        return ''\n             else:\n-                return format_func(col_format, col[idx])\n+                if col.shape[0] > 0:\n+                    return format_func(col_format, col[idx])\n+                else:\n+                    return ''\n \n         # Add formatted values if within bounds allowed by max_lines\n         for idx in indices:\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6503", "model_patch": "diff --git a/networkx/algorithms/tree/operations.py b/networkx/algorithms/tree/operations.py\nindex dfa8a5c..9f0d871 100644\n--- a/networkx/algorithms/tree/operations.py\n+++ b/networkx/algorithms/tree/operations.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Operations on trees.\"\"\"\n from functools import partial\n from itertools import accumulate, chain\n@@ -8,6 +9,8 @@ __all__ = [\"join\"]\n \n \n def join(rooted_trees, label_attribute=None):\n+    if label_attribute is None:\n+        label_attribute = \"_old\"\n     \"\"\"Returns a new rooted tree with a root node joined with the roots\n     of each of the given rooted trees.\n \n@@ -103,4 +106,4 @@ def join(rooted_trees, label_attribute=None):\n     R.add_node(0)\n     R.add_edges_from((0, root) for root in roots)\n \n-    return R\n+    return R\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6098", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 563968a..5b239f5 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -838,7 +838,7 @@ def draw_networkx_edges(\n                 mutation_scale=mutation_scale,\n                 color=arrow_color,\n                 linewidth=line_width,\n-                connectionstyle=_connectionstyle,\n+                connectionstyle=connectionstyle,\n                 linestyle=linestyle,\n                 zorder=1,\n             )  # arrows go behind nodes\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14295", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex cf86591..cd5053b 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -719,37 +719,8 @@ reduce these to 2 dimensions using the naxis kwarg.\n         if self.wcs is None:\n             return\n \n-        # Nothing to be done if no PV parameters attached\n-        pv = self.wcs.get_pv()\n-        if not pv:\n-            return\n-\n-        # Nothing to be done if axes don't use SIP distortion parameters\n-        if self.sip is None:\n-            return\n-\n-        # Nothing to be done if any radial terms are present...\n-        # Loop over list to find any radial terms.\n-        # Certain values of the `j' index are used for storing\n-        # radial terms; refer to Equation (1) in\n-        # <http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf>.\n-        pv = np.asarray(pv)\n-        # Loop over distinct values of `i' index\n-        for i in set(pv[:, 0]):\n-            # Get all values of `j' index for this value of `i' index\n-            js = set(pv[:, 1][pv[:, 0] == i])\n-            # Find max value of `j' index\n-            max_j = max(js)\n-            for j in (3, 11, 23, 39):\n-                if j < max_j and j in js:\n-                    return\n-\n-        self.wcs.set_pv([])\n-        warnings.warn(\n-            \"Removed redundant SCAMP distortion parameters \"\n-            + \"because SIP parameters are also present\",\n-            FITSFixedWarning,\n-        )\n+        def _fix_scamp(self):\n+            pass\n \n     def fix(self, translate_units=\"\", naxis=None):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13087", "model_patch": "diff --git a/sklearn/calibration.py b/sklearn/calibration.py\nindex 142eda3..745dd12 100644\n--- a/sklearn/calibration.py\n+++ b/sklearn/calibration.py\n@@ -519,7 +519,7 @@ class _SigmoidCalibration(BaseEstimator, RegressorMixin):\n         return expit(-(self.a_ * T + self.b_))\n \n \n-def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n+def calibration_curve(y_true, y_prob, normalize=False, bins=None, n_bins=5):\n     \"\"\"Compute true and predicted probabilities for a calibration curve.\n \n      The method assumes the inputs come from a binary classifier.\n"}
