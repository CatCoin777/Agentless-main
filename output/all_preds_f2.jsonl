{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-20584", "model_patch": "diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py\nindex 1d895d4..62ddcf4 100644\n--- a/lib/matplotlib/collections.py\n+++ b/lib/matplotlib/collections.py\n@@ -1461,8 +1461,7 @@ class LineCollection(Collection):\n         segments = []\n \n         for path in self._paths:\n-            vertices = [vertex for vertex, _ in path.iter_segments()]\n-            vertices = np.asarray(vertices)\n+            vertices = path.vertices\n             segments.append(vertices)\n \n         return segments\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-23412", "model_patch": "diff --git a/lib/matplotlib/patches.py b/lib/matplotlib/patches.py\nindex 1eefb1e..2c29e57 100644\n--- a/lib/matplotlib/patches.py\n+++ b/lib/matplotlib/patches.py\n@@ -587,9 +587,7 @@ class Patch(artist.Artist):\n         if not self.get_visible():\n             return\n         # Patch has traditionally ignored the dashoffset.\n-        with cbook._setattr_cm(\n-                 self, _dash_pattern=(0, self._dash_pattern[1])), \\\n-             self._bind_draw_path_function(renderer) as draw_path:\n+        with self._bind_draw_path_function(renderer) as draw_path:\n             path = self.get_path()\n             transform = self.get_transform()\n             tpath = transform.transform_path_non_affine(path)\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24189", "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 85ee34a..1f735dc 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -2019,10 +2019,13 @@ default: %(va)s\n                 elif method == 'nested':\n                     nested_mosaic = arg\n                     j, k = key\n-                    # recursively add the nested mosaic\n+                    # recursively add the nested mosaic without passing width/height ratios\n                     rows, cols = nested_mosaic.shape\n+                    nested_gridspec_kw = gridspec_kw.copy()\n+                    nested_gridspec_kw.pop('width_ratios', None)\n+                    nested_gridspec_kw.pop('height_ratios', None)\n                     nested_output = _do_layout(\n-                        gs[j, k].subgridspec(rows, cols, **gridspec_kw),\n+                        gs[j, k].subgridspec(rows, cols, **nested_gridspec_kw),\n                         nested_mosaic,\n                         *_identify_keys_and_nested(nested_mosaic)\n                     )\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-24570", "model_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex a767323..752306d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -166,10 +166,10 @@ def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n         descent = max(d for h, d in hd_list)\n         height = height_descent + descent\n         offsets = [0. for h, d in hd_list]\n-    elif align in [\"left\", \"top\"]:\n+    elif align in [\"left\", \"bottom\"]:\n         descent = 0.\n         offsets = [d for h, d in hd_list]\n-    elif align in [\"right\", \"bottom\"]:\n+    elif align in [\"right\", \"top\"]:\n         descent = 0.\n         offsets = [height - h + d for h, d in hd_list]\n     elif align == \"center\":\n"}
{"model_name_or_path": "agentless", "instance_id": "matplotlib__matplotlib-25346", "model_patch": "diff --git a/lib/matplotlib/_constrained_layout.py b/lib/matplotlib/_constrained_layout.py\nindex 49e42c8..1c867b8 100644\n--- a/lib/matplotlib/_constrained_layout.py\n+++ b/lib/matplotlib/_constrained_layout.py\n@@ -375,6 +375,13 @@ def make_layout_margins(layoutgrids, fig, renderer, *, w_pad=0, h_pad=0,\n         margin['bottom'] += pos.y0 - bbox.y0\n         margin['top'] += bbox.y1 - pos.y1\n \n+        # Account for wrapped title height\n+        title = ax.title\n+        if title.get_visible() and title.get_wrap():\n+            title_bbox = title.get_tightbbox(renderer)\n+            title_height = title_bbox.height\n+            margin['top'] += title_height\n+\n         # make margin for colorbars.  These margins go in the\n         # padding margin, versus the margin for axes decorators.\n         for cbax in ax._colorbars:\n"}
{"model_name_or_path": "agentless", "instance_id": "mwaskom__seaborn-3276", "model_patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex d9b79f4..f2fdd88 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -296,9 +296,8 @@ class _HeatMapper:\n         # Remove all the Axes spines\n         despine(ax=ax, left=True, bottom=True)\n \n-        # setting vmin/vmax in addition to norm is deprecated\n-        # so avoid setting if norm is set\n-        if \"norm\" not in kws:\n+        # setting vmin/vmax should be respected even if norm=None is provided\n+        if \"norm\" not in kws or kws[\"norm\"] is None:\n             kws.setdefault(\"vmin\", self.vmin)\n             kws.setdefault(\"vmax\", self.vmax)\n \n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4182", "model_patch": "diff --git a/xarray/core/formatting_html.py b/xarray/core/formatting_html.py\nindex 203c590..684afdf 100644\n--- a/xarray/core/formatting_html.py\n+++ b/xarray/core/formatting_html.py\n@@ -184,7 +184,7 @@ def dim_section(obj):\n def array_section(obj):\n     # \"unique\" id to expand/collapse the section\n     data_id = \"section-\" + str(uuid.uuid4())\n-    collapsed = \"\"\n+    collapsed = \"checked\"\n     variable = getattr(obj, \"variable\", obj)\n     preview = escape(inline_variable_array_repr(variable, max_width=70))\n     data_repr = short_data_repr_html(obj)\n"}
{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-5682", "model_patch": "diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py\nindex 4272598..957a5b2 100644\n--- a/xarray/core/formatting.py\n+++ b/xarray/core/formatting.py\n@@ -141,6 +141,9 @@ def format_item(x, timedelta_format=None, quote_strings=True):\n     if isinstance(x, (np.timedelta64, timedelta)):\n         return format_timedelta(x, timedelta_format=timedelta_format)\n     elif isinstance(x, (str, bytes)):\n+        # Do not quote strings that start with '$' and end with '$' as they are likely LaTeX expressions\n+        if isinstance(x, str) and x.startswith('$') and x.endswith('$'):\n+            return x\n         return repr(x) if quote_strings else x\n     elif np.issubdtype(type(x), np.floating):\n         return f\"{x:.4}\"\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-11502", "model_patch": "diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py\nindex 6c79a21..82f18a6 100644\n--- a/sphinx/transforms/i18n.py\n+++ b/sphinx/transforms/i18n.py\n@@ -512,10 +512,7 @@ class Locale(SphinxTransform):\n                 node['raw_entries'] = entries\n                 node['entries'] = new_entries\n \n-        # remove translated attribute that is used for avoiding double translation.\n-        matcher = NodeMatcher(translated=Any)\n-        for translated in self.document.findall(matcher):  # type: nodes.Element\n-            translated.delattr('translated')\n+        # Keep the translated attribute for use by extensions.\n \n \n class RemoveTranslatableInline(SphinxTransform):\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9320", "model_patch": "diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py\nindex 9978773..af41769 100644\n--- a/sphinx/cmd/quickstart.py\n+++ b/sphinx/cmd/quickstart.py\n@@ -147,6 +147,8 @@ def do_prompt(text: str, default: str = None, validator: Callable[[str], Any] =\n             prompt = colorize(COLOR_QUESTION, prompt, input_mode=False)\n         x = term_input(prompt).strip()\n         if default and not x:\n+            if text == \"Please enter a new root path name (or just Enter to exit)\":\n+                return False  # Exit the loop and the prompt\n             x = default\n         try:\n             x = validator(x)\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-9698", "model_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex bcb7471..aaa0b4e 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -796,7 +796,7 @@ class PyMethod(PyObject):\n         if 'classmethod' in self.options:\n             return _('%s() (%s class method)') % (methname, clsname)\n         elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n+            return _('%s (%s property)') % (methname, clsname)\n         elif 'staticmethod' in self.options:\n             return _('%s() (%s static method)') % (methname, clsname)\n         else:\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-11788", "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex d19d26f..5ecd95a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1452,7 +1452,7 @@ class LatexPrinter(Printer):\n     def _print_SingularityFunction(self, expr):\n         shift = self._print(expr.args[0] - expr.args[1])\n         power = self._print(expr.args[2])\n-        tex = r\"{\\langle %s \\rangle}^ %s\" % (shift, power)\n+        tex = r\"{\\langle %s \\rangle}^{%s}\" % (shift, power)\n         return tex\n \n     def _print_Heaviside(self, expr, exp=None):\n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-24723", "model_patch": "diff --git a/sympy/stats/matrix_distributions.py b/sympy/stats/matrix_distributions.py\nindex 684651a..769fa3c 100644\n--- a/sympy/stats/matrix_distributions.py\n+++ b/sympy/stats/matrix_distributions.py\n@@ -450,7 +450,7 @@ class MatrixNormalDistribution(MatrixDistribution):\n                     \"or MatrixSymbol\" % str(x))\n         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n         num = exp(-Trace(term1)/S(2))\n-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)\n         return num/den\n \n def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n"}
{"model_name_or_path": "agentless", "instance_id": "plotly__plotly.py-1966", "model_patch": "diff --git a/packages/python/plotly/plotly/express/_core.py b/packages/python/plotly/plotly/express/_core.py\nindex 897ecfd..b873583 100644\n--- a/packages/python/plotly/plotly/express/_core.py\n+++ b/packages/python/plotly/plotly/express/_core.py\n@@ -1267,7 +1267,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"row\":\n                     row = m.val_map[val]\n                     if args[\"facet_row\"] and len(row_labels) < row:\n-                        row_labels.append(args[\"facet_row\"] + \"=\" + str(val))\n+                        row_labels.append(get_decorated_label(args, args[\"facet_row\"], \"facet_row\") + \"=\" + str(val))\n                 else:\n                     if (\n                         bool(args.get(\"marginal_x\", False))\n@@ -1282,7 +1282,7 @@ def make_figure(args, constructor, trace_patch={}, layout_patch={}):\n                 if m.facet == \"col\":\n                     col = m.val_map[val]\n                     if args[\"facet_col\"] and len(col_labels) < col:\n-                        col_labels.append(args[\"facet_col\"] + \"=\" + str(val))\n+                        col_labels.append(get_decorated_label(args, args[\"facet_col\"], \"facet_col\") + \"=\" + str(val))\n                     if facet_col_wrap:  # assumes no facet_row, no marginals\n                         row = 1 + ((col - 1) // facet_col_wrap)\n                         col = 1 + ((col - 1) % facet_col_wrap)\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..e65214a 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -495,7 +495,11 @@ def draw_networkx_edges(\n ):\n     \"\"\"Draw the edges of the graph G.\n \n-    This draws only the edges of the graph G.\n+    This draws only the edges of the graph G. If a `nodelist` is provided, only\n+    edges with both endpoints in the `nodelist` will be drawn.\n+\n+    This draws only the edges of the graph G. If a `nodelist` is provided, only\n+    edges with both endpoints in the `nodelist` will be drawn.\n \n     Parameters\n     ----------\n@@ -627,6 +631,10 @@ def draw_networkx_edges(\n \n     if edgelist is None:\n         edgelist = list(G.edges())\n+    \n+    # Filter edgelist to only include edges where both nodes are in nodelist\n+    if nodelist is not None:\n+        edgelist = [e for e in edgelist if e[0] in nodelist and e[1] in nodelist]\n \n     if len(edgelist) == 0:  # no edges!\n         return []\n"}
