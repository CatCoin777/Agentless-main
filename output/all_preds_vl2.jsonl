{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-13838", "model_patch": "diff --git a/astropy/table/pprint.py b/astropy/table/pprint.py\nindex 2d557c7..7bb90a1 100644\n--- a/astropy/table/pprint.py\n+++ b/astropy/table/pprint.py\n@@ -394,6 +394,11 @@ class TableFormatter:\n             multidim1 = tuple(n - 1 for n in multidims)\n             trivial_multidims = np.prod(multidims) == 1\n \n+            if trivial_multidims:\n+                n = np.prod(multidims)\n+                multidim0 = (0,) * len(multidims)\n+                multidim1 = (n-1,) * len(multidims)\n+\n         i_dashes = None\n         i_centers = []  # Line indexes where content should be centered\n         n_header = 0\n"}
{"model_name_or_path": "agentless", "instance_id": "astropy__astropy-14295", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex cf86591..faed3c3 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -707,49 +707,9 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n     def _fix_scamp(self):\n         \"\"\"\n-        Remove SCAMP's PVi_m distortion parameters if SIP distortion parameters\n-        are also present. Some projects (e.g., Palomar Transient Factory)\n-        convert SCAMP's distortion parameters (which abuse the PVi_m cards) to\n-        SIP. However, wcslib gets confused by the presence of both SCAMP and\n-        SIP distortion parameters.\n-\n-        See https://github.com/astropy/astropy/issues/299.\n+        This function should be removed as it causes the bug #14255.\n         \"\"\"\n-        # Nothing to be done if no WCS attached\n-        if self.wcs is None:\n-            return\n-\n-        # Nothing to be done if no PV parameters attached\n-        pv = self.wcs.get_pv()\n-        if not pv:\n-            return\n-\n-        # Nothing to be done if axes don't use SIP distortion parameters\n-        if self.sip is None:\n-            return\n-\n-        # Nothing to be done if any radial terms are present...\n-        # Loop over list to find any radial terms.\n-        # Certain values of the `j' index are used for storing\n-        # radial terms; refer to Equation (1) in\n-        # <http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf>.\n-        pv = np.asarray(pv)\n-        # Loop over distinct values of `i' index\n-        for i in set(pv[:, 0]):\n-            # Get all values of `j' index for this value of `i' index\n-            js = set(pv[:, 1][pv[:, 0] == i])\n-            # Find max value of `j' index\n-            max_j = max(js)\n-            for j in (3, 11, 23, 39):\n-                if j < max_j and j in js:\n-                    return\n-\n-        self.wcs.set_pv([])\n-        warnings.warn(\n-            \"Removed redundant SCAMP distortion parameters \"\n-            + \"because SIP parameters are also present\",\n-            FITSFixedWarning,\n-        )\n+        pass\n \n     def fix(self, translate_units=\"\", naxis=None):\n         \"\"\"\n"}
{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13087", "model_patch": "diff --git a/sklearn/calibration.py b/sklearn/calibration.py\nindex 142eda3..745dd12 100644\n--- a/sklearn/calibration.py\n+++ b/sklearn/calibration.py\n@@ -519,7 +519,7 @@ class _SigmoidCalibration(BaseEstimator, RegressorMixin):\n         return expit(-(self.a_ * T + self.b_))\n \n \n-def calibration_curve(y_true, y_prob, normalize=False, n_bins=5):\n+def calibration_curve(y_true, y_prob, normalize=False, bins=None, n_bins=5):\n     \"\"\"Compute true and predicted probabilities for a calibration curve.\n \n      The method assumes the inputs come from a binary classifier.\n"}
{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8028", "model_patch": "diff --git a/sphinx/ext/autosummary/generate.py b/sphinx/ext/autosummary/generate.py\nindex ec986a0..60af0b3 100644\n--- a/sphinx/ext/autosummary/generate.py\n+++ b/sphinx/ext/autosummary/generate.py\n@@ -182,7 +182,15 @@ class ModuleScanner:\n     def __init__(self, app: Any, obj: Any) -> None:\n         self.app = app\n         self.object = obj\n-\n+        self.instance_attributes = self.get_instance_attributes()\n+\n+    def get_instance_attributes(self):\n+        instance_attributes = {}\n+        for name, value in inspect.getmembers(self.object):\n+            if not name.startswith('_') and not inspect.isroutine(value):\n+                # Documentation for instance attributes\n+                instance_attributes[name] = inspect.getdoc(value)\n+        return instance_attributes\n     def get_object_type(self, name: str, value: Any) -> str:\n         return get_documenter(self.app, value, self.object).objtype\n \n"}
{"model_name_or_path": "agentless", "instance_id": "sympy__sympy-21769", "model_patch": "diff --git a/sympy/physics/quantum/cg.py b/sympy/physics/quantum/cg.py\nindex ae6b99a..444861f 100644\n--- a/sympy/physics/quantum/cg.py\n+++ b/sympy/physics/quantum/cg.py\n@@ -218,7 +218,7 @@ class CG(Wigner3j):\n     def _latex(self, printer, *args):\n         label = map(printer._print, (self.j3, self.m3, self.j1,\n                     self.m1, self.j2, self.m2))\n-        return r'C^{%s,%s}_{%s,%s,%s,%s}' % tuple(label)\n+        return r'{C^{%s,%s}_{%s,%s,%s,%s}}' % tuple(label)\n \n \n class Wigner6j(Expr):\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6503", "model_patch": "diff --git a/networkx/algorithms/tree/operations.py b/networkx/algorithms/tree/operations.py\nindex dfa8a5c..85ae105 100644\n--- a/networkx/algorithms/tree/operations.py\n+++ b/networkx/algorithms/tree/operations.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Operations on trees.\"\"\"\n from functools import partial\n from itertools import accumulate, chain\n@@ -7,7 +8,7 @@ import networkx as nx\n __all__ = [\"join\"]\n \n \n-def join(rooted_trees, label_attribute=None):\n+def join(rooted_trees, label_attribute=\"_old\"):\n     \"\"\"Returns a new rooted tree with a root node joined with the roots\n     of each of the given rooted trees.\n \n@@ -103,4 +104,4 @@ def join(rooted_trees, label_attribute=None):\n     R.add_node(0)\n     R.add_edges_from((0, root) for root in roots)\n \n-    return R\n+    return R\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-5616", "model_patch": "diff --git a/networkx/algorithms/euler.py b/networkx/algorithms/euler.py\nindex 5b844cf..8f3dd24 100644\n--- a/networkx/algorithms/euler.py\n+++ b/networkx/algorithms/euler.py\n@@ -287,12 +287,22 @@ def has_eulerian_path(G, source=None):\n             unbalanced_ins <= 1 and unbalanced_outs <= 1 and nx.is_weakly_connected(G)\n         )\n     else:\n+        # Remove isolated nodes (if any) without altering the input graph\n+        nodes_remove = [v for v in G if G.degree[v] == 0]\n+        if nodes_remove:\n+            G = G.copy()\n+            G.remove_nodes_from(nodes_remove)\n         # We know it is not eulerian, so degree of source must be odd.\n         if source is not None and G.degree[source] % 2 != 1:\n             return False\n \n-        # Sum is 2 since we know it is not eulerian (which implies sum is 0)\n-        return sum(d % 2 == 1 for v, d in G.degree()) == 2 and nx.is_connected(G)\n+        unbalanced_deg = 0\n+        for v in G:\n+            if G.degree[v] % 2 == 1:\n+                unbalanced_deg += 1\n+                if unbalanced_deg > 2:\n+                    return False\n+        return nx.is_connected(G)\n \n \n def eulerian_path(G, source=None, keys=False):\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-6098", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 563968a..5fe3390 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -838,7 +838,7 @@ def draw_networkx_edges(\n                 mutation_scale=mutation_scale,\n                 color=arrow_color,\n                 linewidth=line_width,\n-                connectionstyle=_connectionstyle,\n+                connectionstyle=connectionstyle, # change from _connectionstyle to connectionstyle\n                 linestyle=linestyle,\n                 zorder=1,\n             )  # arrows go behind nodes\n"}
{"model_name_or_path": "agentless", "instance_id": "networkx__networkx-4378", "model_patch": "diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py\nindex 306bca5..d922536 100644\n--- a/networkx/drawing/nx_pylab.py\n+++ b/networkx/drawing/nx_pylab.py\n@@ -633,6 +633,8 @@ def draw_networkx_edges(\n \n     if nodelist is None:\n         nodelist = list(G.nodes())\n+    else:\n+        nodelist = [n for n in nodelist if n in G.nodes()]\n \n     # FancyArrowPatch handles color=None different from LineCollection\n     if edge_color is None:\n"}
